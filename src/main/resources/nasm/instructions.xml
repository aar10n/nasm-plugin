<?xml version='1.0' encoding='UTF-8'?>
<instructions>
  <instruction name="aaa" category="ARITHMETIC">
    <description>ASCII adjust after addition</description>
  </instruction>
  <instruction name="aad" category="ARITHMETIC">
    <description>ASCII adjust before division</description>
  </instruction>
  <instruction name="aam" category="ARITHMETIC">
    <description>ASCII adjust after multiply</description>
  </instruction>
  <instruction name="aas" category="ARITHMETIC">
    <description>ASCII adjust after subtraction</description>
  </instruction>
  <instruction name="adc" category="ARITHMETIC">
    <description>Add with carry</description>
    <documentation>
      <summary>Add with Carry</summary>
      <description>Adds the source operand, destination operand, and the carry flag (CF) and stores the result in the destination operand.</description>
      <operation>DEST := DEST + SRC + CF</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>Used for multi-precision arithmetic. Typically, follows an ADD instruction.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
        <operand type="REG" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="R_M" />
        <operand type="IMM" />
      </variant>
    </variants>
  </instruction>
  <instruction name="adcx" category="ARITHMETIC">
    <description>Unsigned add with carry flag</description>
  </instruction>
  <instruction name="add" category="ARITHMETIC">
    <description>Add</description>
    <documentation>
      <summary>Add</summary>
      <description>Adds the destination operand (first operand) and the source operand (second operand) and stores the result in the destination operand. The destination operand can be a register or memory location. The source operand can be an immediate value, register, or memory location.</description>
      <operation>DEST := DEST + SRC</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>The OF, SF, ZF, AF, CF, and PF flags are set according to the result.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
        <operand type="REG" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="R_M" />
        <operand type="IMM" />
      </variant>
    </variants>
  </instruction>
  <instruction name="addpd" category="SIMD">
    <description>Add packed double-precision</description>
  </instruction>
  <instruction name="addps" category="SIMD">
    <description>Add packed single-precision</description>
  </instruction>
  <instruction name="addsd" category="SIMD">
    <description>Add scalar double-precision</description>
  </instruction>
  <instruction name="addss" category="SIMD">
    <description>Add scalar single-precision</description>
  </instruction>
  <instruction name="addsubpd" category="SIMD">
    <description>Add/subtract packed double-precision</description>
  </instruction>
  <instruction name="addsubps" category="SIMD">
    <description>Add/subtract packed single-precision</description>
  </instruction>
  <instruction name="adox" category="ARITHMETIC">
    <description>Unsigned add with overflow flag</description>
  </instruction>
  <instruction name="aesdec" category="CRYPTO">
    <description>AES decrypt single round</description>
  </instruction>
  <instruction name="aesdeclast" category="CRYPTO">
    <description>AES decrypt last round</description>
  </instruction>
  <instruction name="aesenc" category="CRYPTO">
    <description>AES encrypt single round</description>
  </instruction>
  <instruction name="aesenclast" category="CRYPTO">
    <description>AES encrypt last round</description>
  </instruction>
  <instruction name="aesimc" category="CRYPTO">
    <description>AES inverse mix columns</description>
  </instruction>
  <instruction name="aeskeygenassist" category="CRYPTO">
    <description>AES key generation assist</description>
  </instruction>
  <instruction name="and" category="LOGIC">
    <description>Logical AND</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="REG8" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM32" />
      </variant>
    </variants>
    <documentation>
      <summary>Logical AND</summary>
      <description>Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location.</description>
      <operation>DEST := DEST AND SRC</operation>
      <flags-affected>OF=0, CF=0, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>OF and CF flags are cleared. The SF, ZF, and PF flags are set according to the result.</notes>
    </documentation>
  </instruction>
  <instruction name="andn" category="BIT_MANIPULATION">
    <description>Logical AND NOT (BMI1)</description>
  </instruction>
  <instruction name="andnpd" category="SIMD">
    <description>Bitwise AND NOT of packed double-precision</description>
  </instruction>
  <instruction name="andnps" category="SIMD">
    <description>Bitwise AND NOT of packed single-precision</description>
  </instruction>
  <instruction name="andpd" category="SIMD">
    <description>Bitwise AND of packed double-precision</description>
  </instruction>
  <instruction name="andps" category="SIMD">
    <description>Bitwise AND of packed single-precision</description>
  </instruction>
  <instruction name="arpl" category="SYSTEM">
    <description>Adjust RPL field of segment selector</description>
  </instruction>
  <instruction name="bextr" category="BIT_MANIPULATION">
    <description>Bit field extract (BMI1)</description>
    <variants>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
    </variants>
    <documentation>
      <summary>Extract contiguous bits from source using start position and length</summary>
      <description>Extracts contiguous bits from the first source operand using an index value and length value specified in the second source operand. Bits 7:0 of the second source specify the start position, and bits 15:8 specify the length. The extracted bits are written to the destination register with higher-order bits zeroed.</description>
      <operation>DEST := Extract bits from SRC1[start:start+length-1]</operation>
      <flags-affected>ZF is updated based on result; AF, SF, PF are undefined; other flags cleared</flags-affected>
      <notes>Requires BMI1 CPUID feature flag. Not supported in real mode or virtual-8086 mode. In 64-bit mode, requires VEX.W1 for 64-bit operands.</notes>
    </documentation>
  </instruction>
  <instruction name="blendpd" category="SIMD">
    <description>Blend packed double-precision</description>
  </instruction>
  <instruction name="blendps" category="SIMD">
    <description>Blend packed single-precision</description>
  </instruction>
  <instruction name="blendvpd" category="SIMD">
    <description>Variable blend packed double-precision</description>
  </instruction>
  <instruction name="blendvps" category="SIMD">
    <description>Variable blend packed single-precision</description>
  </instruction>
  <instruction name="blsi" category="BIT_MANIPULATION">
    <description>Extract lowest set isolated bit (BMI1)</description>
  </instruction>
  <instruction name="blsmsk" category="BIT_MANIPULATION">
    <description>Get mask up to lowest set bit (BMI1)</description>
  </instruction>
  <instruction name="blsr" category="BIT_MANIPULATION">
    <description>Reset lowest set bit (BMI1)</description>
  </instruction>
  <instruction name="bound" category="SYSTEM">
    <description>Check array index against bounds</description>
  </instruction>
  <instruction name="bsf" category="BIT_MANIPULATION">
    <description>Bit scan forward</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Bit Scan Forward</summary>
      <description>Searches the source operand for the least significant set bit (1 bit). If a set bit is found, its bit index is stored in the destination register.</description>
      <operation>if SRC = 0 then
  ZF := 1
  DEST is undefined
else
  DEST := BitIndexOfLeastSignificantSetBit(SRC)
  ZF := 0</operation>
      <flags-affected>ZF (OF, SF, AF, PF, CF undefined)</flags-affected>
      <notes>If source is 0, ZF is set and destination is undefined. Otherwise, ZF is cleared.</notes>
    </documentation>
  </instruction>
  <instruction name="bsr" category="BIT_MANIPULATION">
    <description>Bit scan reverse</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Bit Scan Reverse</summary>
      <description>Searches the source operand for the most significant set bit (1 bit). If a set bit is found, its bit index is stored in the destination register.</description>
      <operation>if SRC = 0 then
  ZF := 1
  DEST is undefined
else
  DEST := BitIndexOfMostSignificantSetBit(SRC)
  ZF := 0</operation>
      <flags-affected>ZF (OF, SF, AF, PF, CF undefined)</flags-affected>
      <notes>If source is 0, ZF is set and destination is undefined. Otherwise, ZF is cleared.</notes>
    </documentation>
  </instruction>
  <instruction name="bswap" category="DATA_MOVEMENT">
    <description>Byte swap</description>
    <variants>
      <variant>
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="REG64" />
      </variant>
    </variants>
    <documentation>
      <summary>Reverse the byte order of a 32-bit or 64-bit register</summary>
      <description>Reverses the byte order of a 32-bit or 64-bit destination register, converting between little-endian and big-endian formats. This instruction is provided for converting little-endian values to big-endian format and vice versa. The result for 16-bit registers is undefined; use XCHG for 16-bit byte swapping.</description>
      <operation>DEST := Reverse byte order of DEST</operation>
      <flags-affected>None</flags-affected>
      <notes>Not supported on processors earlier than Intel 486. In 64-bit mode, default operation size is 32 bits; REX.W prefix enables 64-bit operation.</notes>
    </documentation>
  </instruction>
  <instruction name="bt" category="BIT_MANIPULATION">
    <description>Bit test</description>
    <variants>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Bit Test</summary>
      <description>Selects the bit in the first operand at the position specified by the second operand and copies it to the carry flag.</description>
      <operation>CF := Bit(DEST, BitOffset)</operation>
      <flags-affected>CF (OF, SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Does not modify the operand, only sets CF to the value of the tested bit.</notes>
    </documentation>
  </instruction>
  <instruction name="btc" category="BIT_MANIPULATION">
    <description>Bit test and complement</description>
    <variants>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Bit Test and Complement</summary>
      <description>Selects the bit in the first operand at the position specified by the second operand, stores the current value of the bit in CF, then complements the bit.</description>
      <operation>CF := Bit(DEST, BitOffset)
Bit(DEST, BitOffset) := NOT Bit(DEST, BitOffset)</operation>
      <flags-affected>CF (OF, SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Can be used with LOCK prefix for atomic operations.</notes>
    </documentation>
  </instruction>
  <instruction name="btr" category="BIT_MANIPULATION">
    <description>Bit test and reset</description>
    <variants>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Bit Test and Reset</summary>
      <description>Selects the bit in the first operand at the position specified by the second operand, stores the current value of the bit in CF, then clears the bit to 0.</description>
      <operation>CF := Bit(DEST, BitOffset)
Bit(DEST, BitOffset) := 0</operation>
      <flags-affected>CF (OF, SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Can be used with LOCK prefix for atomic operations.</notes>
    </documentation>
  </instruction>
  <instruction name="bts" category="BIT_MANIPULATION">
    <description>Bit test and set</description>
    <variants>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Bit Test and Set</summary>
      <description>Selects the bit in the first operand at the position specified by the second operand, stores the current value of the bit in CF, then sets the bit to 1.</description>
      <operation>CF := Bit(DEST, BitOffset)
Bit(DEST, BitOffset) := 1</operation>
      <flags-affected>CF (OF, SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Can be used with LOCK prefix for atomic operations.</notes>
    </documentation>
  </instruction>
  <instruction name="bzhi" category="BIT_MANIPULATION">
    <description>Zero high bits starting with specified bit position (BMI2)</description>
    <variants>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
    </variants>
    <documentation>
      <summary>Zero high bits starting from specified bit position</summary>
      <description>Copies bits from the source operand to the destination and clears (zeroes) all higher bits starting from the bit position specified by the index in the second source operand. The index is specified by the lowest 8 bits of the second source and is saturated at (operand size - 1).</description>
      <operation>DEST := SRC with high bits zeroed from index position</operation>
      <flags-affected>ZF and SF updated based on result; CF set if index &gt; (operand size - 1); OF cleared; AF and PF undefined</flags-affected>
      <notes>Requires BMI2 CPUID feature flag. Not supported in real mode or virtual-8086 mode. In 64-bit mode, VEX.W1 required for 64-bit operands. Intrinsics: _bzhi_u32() and _bzhi_u64().</notes>
    </documentation>
  </instruction>
  <instruction name="call" category="CONTROL_FLOW">
    <description>Call procedure</description>
    <variants>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
      <variant>
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Call Procedure</summary>
      <description>Saves procedure linking information on the stack and branches to the called procedure. The address of the instruction following the CALL instruction is pushed onto the stack.</description>
      <operation>push(RIP)
RIP := target</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, pushes a 64-bit return address.</notes>
    </documentation>
  </instruction>
  <instruction name="cbw" category="CONVERSION">
    <description>Convert byte to word</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Convert Byte to Word</summary>
      <description>Sign-extends the byte in AL to fill AX.</description>
      <operation>AX := SignExtend(AL)</operation>
      <flags-affected>None</flags-affected>
      <notes>Part of the sign extension family: CBW (AL-&gt;AX), CWDE (AX-&gt;EAX), CDQE (EAX-&gt;RAX).</notes>
    </documentation>
  </instruction>
  <instruction name="cdq" category="CONVERSION">
    <description>Convert doubleword to quadword</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Convert Doubleword to Quadword</summary>
      <description>Sign-extends the doubleword in EAX to fill EDX:EAX.</description>
      <operation>EDX:EAX := SignExtend(EAX)</operation>
      <flags-affected>None</flags-affected>
      <notes>Used before IDIV to prepare dividend. Part of family: CWD (AX-&gt;DX:AX), CDQ (EAX-&gt;EDX:EAX), CQO (RAX-&gt;RDX:RAX).</notes>
    </documentation>
  </instruction>
  <instruction name="cdqe" category="CONVERSION">
    <description>Convert doubleword to quadword</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Convert Doubleword to Quadword Extended</summary>
      <description>Sign-extends the doubleword in EAX to fill RAX. Only available in 64-bit mode.</description>
      <operation>RAX := SignExtend(EAX)</operation>
      <flags-affected>None</flags-affected>
      <notes>Part of the sign extension family: CBW (AL-&gt;AX), CWDE (AX-&gt;EAX), CDQE (EAX-&gt;RAX).</notes>
    </documentation>
  </instruction>
  <instruction name="clc" category="SYSTEM">
    <description>Clear carry flag</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Clear Carry Flag</summary>
      <description>Clears the CF (carry flag) in the RFLAGS register.</description>
      <operation>CF := 0</operation>
      <flags-affected>CF (cleared)</flags-affected>
      <notes>Often used before operations that use or test the carry flag.</notes>
    </documentation>
  </instruction>
  <instruction name="cld" category="SYSTEM">
    <description>Clear direction flag</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Clear Direction Flag</summary>
      <description>Clears the DF (direction flag) in the RFLAGS register. When DF is clear, string operations increment the pointer registers (RSI and RDI).</description>
      <operation>DF := 0</operation>
      <flags-affected>DF (cleared)</flags-affected>
      <notes>Should be called before string operations that process memory in increasing address order.</notes>
    </documentation>
  </instruction>
  <instruction name="clflush" category="SYSTEM">
    <description>Flush cache line</description>
  </instruction>
  <instruction name="clflushopt" category="SYSTEM">
    <description>Flush cache line optimized</description>
  </instruction>
  <instruction name="cli" category="SYSTEM">
    <description>Clear interrupt flag</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Clear Interrupt Flag</summary>
      <description>Clears the IF (interrupt flag) in the EFLAGS register. When the IF flag is cleared, the processor ignores maskable external interrupts. This instruction is privileged (CPL=0) and can only be executed in kernel mode.</description>
      <operation>IF := 0</operation>
      <flags-affected>IF (cleared)</flags-affected>
      <notes>Privileged instruction. Only affects maskable interrupts; non-maskable interrupts (NMI) are not affected.</notes>
    </documentation>
  </instruction>
  <instruction name="clts" category="SYSTEM">
    <description>Clear task-switched flag</description>
  </instruction>
  <instruction name="clwb" category="SYSTEM">
    <description>Cache line write back</description>
  </instruction>
  <instruction name="cmc" category="SYSTEM">
    <description>Complement carry flag</description>
  </instruction>
  <instruction name="cmov">
    <description>The CMOV instruction transfers data from a source operand to a destination register only if specified status flags meet certain conditions. It supports multiple condition codes for signed/unsigned comparisons and flag tests. The processor unconditionally loads the source into a temporary register, then conditionally moves it to the destination, avoiding branch misprediction penalties.</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditionally move data from source to destination based on processor flags</summary>
      <description>The CMOV instruction transfers data from a source operand to a destination register only if specified status flags meet certain conditions. It supports multiple condition codes for signed/unsigned comparisons and flag tests. The processor unconditionally loads the source into a temporary register, then conditionally moves it to the destination, avoiding branch misprediction penalties.</description>
      <operation>IF condition THEN
  DEST := SRC</operation>
      <flags-affected>None (reads various flags depending on condition; does not modify any flags)</flags-affected>
      <notes>Introduced in P6 family processors. Condition codes: CMOVA/CMOVNBE, CMOVAE/CMOVNB/CMOVNC, CMOVB/CMOVC/CMOVNAE, CMOVBE/CMOVNA, CMOVE/CMOVZ, CMOVNE/CMOVNZ, CMOVG/CMOVNLE, CMOVGE/CMOVNL, CMOVL/CMOVNGE, CMOVLE/CMOVNG, CMOVO, CMOVNO, CMOVS, CMOVNS, CMOVP/CMOVPE, CMOVNP/CMOVPO.</notes>
    </documentation>
  </instruction>
  <instruction name="cmova" category="DATA_MOVEMENT">
    <description>Conditional move if above (unsigned)</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Above (unsigned &gt;)</summary>
      <description>Conditionally moves the source operand to the destination register if CF=0 and ZF=0 (unsigned greater than). If condition is false, destination remains unchanged.</description>
      <operation>if (CF=0 and ZF=0) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNBE. Used after CMP for unsigned comparisons. Destination must be a register. No 8-bit form available.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovae" category="DATA_MOVEMENT">
    <description>Conditional move if above or equal (unsigned)</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Above or Equal (unsigned &gt;=)</summary>
      <description>Conditionally moves the source operand to the destination register if CF=0 (unsigned greater than or equal). If condition is false, destination remains unchanged.</description>
      <operation>if (CF=0) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonyms: CMOVNB, CMOVNC. Used after CMP for unsigned comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovb" category="DATA_MOVEMENT">
    <description>Conditional move if below (unsigned)</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Below (unsigned &lt;)</summary>
      <description>Conditionally moves the source operand to the destination register if CF=1 (unsigned less than). If condition is false, destination remains unchanged.</description>
      <operation>if (CF=1) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonyms: CMOVNAE, CMOVC. Used after CMP for unsigned comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovbe" category="DATA_MOVEMENT">
    <description>Conditional move if below or equal (unsigned)</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Below or Equal (unsigned &lt;=)</summary>
      <description>Conditionally moves the source operand to the destination register if CF=1 or ZF=1 (unsigned less than or equal). If condition is false, destination remains unchanged.</description>
      <operation>if (CF=1 or ZF=1) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNA. Used after CMP for unsigned comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovc" category="DATA_MOVEMENT">
    <description>Conditional move if carry</description>
  </instruction>
  <instruction name="cmove" category="DATA_MOVEMENT">
    <description>Conditional move if equal</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Equal</summary>
      <description>Conditionally moves the source operand to the destination register if ZF=1 (operands are equal). If condition is false, destination remains unchanged.</description>
      <operation>if (ZF=1) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVZ. Used after CMP or arithmetic operations. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovg" category="DATA_MOVEMENT">
    <description>Conditional move if greater</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Greater (signed &gt;)</summary>
      <description>Conditionally moves the source operand to the destination register if ZF=0 and SF=OF (signed greater than). If condition is false, destination remains unchanged.</description>
      <operation>if (ZF=0 and SF=OF) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNLE. Used after CMP for signed comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovge" category="DATA_MOVEMENT">
    <description>Conditional move if greater or equal</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Greater or Equal (signed &gt;=)</summary>
      <description>Conditionally moves the source operand to the destination register if SF=OF (signed greater than or equal). If condition is false, destination remains unchanged.</description>
      <operation>if (SF=OF) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNL. Used after CMP for signed comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovl" category="DATA_MOVEMENT">
    <description>Conditional move if less</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Less (signed &lt;)</summary>
      <description>Conditionally moves the source operand to the destination register if SF≠OF (signed less than). If condition is false, destination remains unchanged.</description>
      <operation>if (SF≠OF) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNGE. Used after CMP for signed comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovle" category="DATA_MOVEMENT">
    <description>Conditional move if less or equal</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Less or Equal (signed &lt;=)</summary>
      <description>Conditionally moves the source operand to the destination register if ZF=1 or SF≠OF (signed less than or equal). If condition is false, destination remains unchanged.</description>
      <operation>if (ZF=1 or SF≠OF) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNG. Used after CMP for signed comparisons. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovna" category="DATA_MOVEMENT">
    <description>Conditional move if not above</description>
  </instruction>
  <instruction name="cmovnae" category="DATA_MOVEMENT">
    <description>Conditional move if not above or equal</description>
  </instruction>
  <instruction name="cmovnb" category="DATA_MOVEMENT">
    <description>Conditional move if not below</description>
  </instruction>
  <instruction name="cmovnbe" category="DATA_MOVEMENT">
    <description>Conditional move if not below or equal</description>
  </instruction>
  <instruction name="cmovnc" category="DATA_MOVEMENT">
    <description>Conditional move if not carry</description>
  </instruction>
  <instruction name="cmovne" category="DATA_MOVEMENT">
    <description>Conditional move if not equal</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Conditional Move if Not Equal</summary>
      <description>Conditionally moves the source operand to the destination register if ZF=0 (operands are not equal). If condition is false, destination remains unchanged.</description>
      <operation>if (ZF=0) then DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>Introduced in P6 family. Synonym for CMOVNZ. Used after CMP or arithmetic operations. Destination must be a register.</notes>
    </documentation>
  </instruction>
  <instruction name="cmovng" category="DATA_MOVEMENT">
    <description>Conditional move if not greater</description>
  </instruction>
  <instruction name="cmovnge" category="DATA_MOVEMENT">
    <description>Conditional move if not greater or equal</description>
  </instruction>
  <instruction name="cmovnl" category="DATA_MOVEMENT">
    <description>Conditional move if not less</description>
  </instruction>
  <instruction name="cmovnle" category="DATA_MOVEMENT">
    <description>Conditional move if not less or equal</description>
  </instruction>
  <instruction name="cmovno" category="DATA_MOVEMENT">
    <description>Conditional move if not overflow</description>
  </instruction>
  <instruction name="cmovnp" category="DATA_MOVEMENT">
    <description>Conditional move if not parity</description>
  </instruction>
  <instruction name="cmovns" category="DATA_MOVEMENT">
    <description>Conditional move if not sign</description>
  </instruction>
  <instruction name="cmovnz" category="DATA_MOVEMENT">
    <description>Conditional move if not zero</description>
  </instruction>
  <instruction name="cmovo" category="DATA_MOVEMENT">
    <description>Conditional move if overflow</description>
  </instruction>
  <instruction name="cmovp" category="DATA_MOVEMENT">
    <description>Conditional move if parity</description>
  </instruction>
  <instruction name="cmovpe" category="DATA_MOVEMENT">
    <description>Conditional move if parity even</description>
  </instruction>
  <instruction name="cmovpo" category="DATA_MOVEMENT">
    <description>Conditional move if parity odd</description>
  </instruction>
  <instruction name="cmovs" category="DATA_MOVEMENT">
    <description>Conditional move if sign</description>
  </instruction>
  <instruction name="cmovz" category="DATA_MOVEMENT">
    <description>Conditional move if zero</description>
  </instruction>
  <instruction name="cmp" category="ARITHMETIC">
    <description>Compare</description>
    <documentation>
      <summary>Compare Two Operands</summary>
      <description>Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. The result is discarded.</description>
      <operation>temp := DEST - SRC
(Flags set according to temp, temp discarded)</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>Used in conjunction with conditional jumps and moves.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
        <operand type="REG" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="R_M" />
        <operand type="IMM" />
      </variant>
    </variants>
  </instruction>
  <instruction name="cmppd" category="SIMD">
    <description>Compare packed double-precision</description>
  </instruction>
  <instruction name="cmpps" category="SIMD">
    <description>Compare packed single-precision</description>
  </instruction>
  <instruction name="cmps" category="STRING">
    <description>Compare string</description>
  </instruction>
  <instruction name="cmpsb" category="STRING">
    <description>Compare byte string</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Compare String</summary>
      <description>Compares the byte/word/dword/qword at RSI with the byte/word/dword/qword at RDI, sets flags according to the result, then increments or decrements both pointers.</description>
      <operation>temp := [RSI] - [RDI]
(Flags set according to temp)
RSI := RSI +/- size
RDI := RDI +/- size</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>Often used with REPE/REPNE to compare memory blocks.</notes>
    </documentation>
  </instruction>
  <instruction name="cmpsd" category="SIMD">
    <description>Compare scalar double-precision</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Compare String</summary>
      <description>Compares the byte/word/dword/qword at RSI with the byte/word/dword/qword at RDI, sets flags according to the result, then increments or decrements both pointers.</description>
      <operation>temp := [RSI] - [RDI]
(Flags set according to temp)
RSI := RSI +/- size
RDI := RDI +/- size</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>Often used with REPE/REPNE to compare memory blocks.</notes>
    </documentation>
  </instruction>
  <instruction name="cmpsq" category="STRING">
    <description>Compare quadword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Compare string quadwords at DS:RSI and ES:RDI</summary>
      <description>Compares the quadword (64-bit) at the memory location addressed by RSI with the quadword at the memory location addressed by RDI by performing a subtraction and setting status flags. After the comparison, both RSI and RDI registers are automatically incremented or decremented by 8 based on the Direction Flag (DF). This is the no-operands form of CMPS for quadword-sized operations and is only available in 64-bit mode.</description>
      <operation>TEMP := [DS:RSI] - [ES:RDI]
Set flags according to TEMP
RSI := RSI +/- 8
RDI := RDI +/- 8</operation>
      <flags-affected>CF, OF, SF, ZF, AF, and PF</flags-affected>
      <notes>Can be preceded by REPE/REPZ or REPNE/REPNZ prefixes. Source is DS:RSI (can be overridden), destination is ES:RDI (cannot be overridden). Only available in 64-bit mode.</notes>
    </documentation>
  </instruction>
  <instruction name="cmpss" category="SIMD">
    <description>Compare scalar single-precision</description>
  </instruction>
  <instruction name="cmpsw" category="STRING">
    <description>Compare word string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Compare string words at DS:(R|E)SI and ES:(R|E)DI</summary>
      <description>Compares the word (16-bit) at the memory location addressed by DS:(R|E)SI with the word at the memory location addressed by ES:(R|E)DI by performing a subtraction and setting status flags. After the comparison, both (R|E)SI and (R|E)DI registers are automatically incremented or decremented by 2 based on the Direction Flag (DF). This is the no-operands form of CMPS for word-sized operations.</description>
      <operation>TEMP := [DS:(R|E)SI] - [ES:(R|E)DI]
Set flags according to TEMP
(R|E)SI := (R|E)SI +/- 2
(R|E)DI := (R|E)DI +/- 2</operation>
      <flags-affected>CF, OF, SF, ZF, AF, and PF</flags-affected>
      <notes>Can be preceded by REPE/REPZ or REPNE/REPNZ prefixes. Source is DS:(R|E)SI (can be overridden), destination is ES:(R|E)DI (cannot be overridden).</notes>
    </documentation>
  </instruction>
  <instruction name="cmpxchg" category="DATA_MOVEMENT">
    <description>Compare and exchange</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
    </variants>
    <documentation>
      <summary>Compare and Exchange</summary>
      <description>Compares the accumulator (AL/AX/EAX/RAX) with the destination operand. If equal, the source operand is loaded into the destination. Otherwise, the destination is loaded into the accumulator. Can be combined with the LOCK prefix for atomic operation.</description>
      <operation>if accumulator = DEST then
  ZF := 1
  DEST := SRC
else
  ZF := 0
  accumulator := DEST</operation>
      <flags-affected>OF, SF, ZF, AF, PF, CF</flags-affected>
      <notes>Fundamental primitive for lock-free data structures. Use LOCK prefix for atomicity.</notes>
    </documentation>
  </instruction>
  <instruction name="cmpxchg16b" category="DATA_MOVEMENT">
    <description>Compare and exchange 16 bytes</description>
    <variants>
      <variant>
        <operand type="MEM128" />
      </variant>
    </variants>
    <documentation>
      <summary>Compare and Exchange 16 Bytes</summary>
      <description>Compares RDX:RAX with the 128-bit value in the destination operand. If equal, RCX:RBX is stored in the destination. Otherwise, the destination is loaded into RDX:RAX. Can be combined with the LOCK prefix for atomic operation. Only available in 64-bit mode.</description>
      <operation>if RDX:RAX = DEST then
  ZF := 1
  DEST := RCX:RBX
else
  ZF := 0
  RDX:RAX := DEST</operation>
      <flags-affected>ZF</flags-affected>
      <notes>Used for atomic 128-bit operations on 64-bit systems. Requires CMPXCHG16B CPU feature. Use LOCK prefix for atomicity.</notes>
    </documentation>
  </instruction>
  <instruction name="cmpxchg8b" category="DATA_MOVEMENT">
    <description>Compare and exchange 8 bytes</description>
    <variants>
      <variant>
        <operand type="MEM64" />
      </variant>
    </variants>
    <documentation>
      <summary>Compare and Exchange 8 Bytes</summary>
      <description>Compares EDX:EAX with the 64-bit value in the destination operand. If equal, ECX:EBX is stored in the destination. Otherwise, the destination is loaded into EDX:EAX. Can be combined with the LOCK prefix for atomic operation.</description>
      <operation>if EDX:EAX = DEST then
  ZF := 1
  DEST := ECX:EBX
else
  ZF := 0
  EDX:EAX := DEST</operation>
      <flags-affected>ZF</flags-affected>
      <notes>Used for atomic 64-bit operations on 32-bit systems. Use LOCK prefix for atomicity.</notes>
    </documentation>
  </instruction>
  <instruction name="comisd" category="SIMD">
    <description>Compare scalar ordered double-precision</description>
  </instruction>
  <instruction name="comiss" category="SIMD">
    <description>Compare scalar ordered single-precision</description>
  </instruction>
  <instruction name="cpuid" category="SYSTEM">
    <description>CPU identification</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>CPU Identification</summary>
      <description>Returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers. The information returned depends on the value in EAX when the instruction is executed.</description>
      <operation>EAX, EBX, ECX, EDX := processor_info(EAX, ECX)</operation>
      <flags-affected>None</flags-affected>
      <notes>Input: EAX selects the information leaf, ECX selects sub-leaf (when applicable). Use EAX=0 to get maximum supported leaf and vendor ID. Use EAX=1 to get processor features.</notes>
    </documentation>
  </instruction>
  <instruction name="cqo" category="CONVERSION">
    <description>Convert quadword to octaword</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Convert Quadword to Octaword</summary>
      <description>Sign-extends the quadword in RAX to fill RDX:RAX. Only available in 64-bit mode.</description>
      <operation>RDX:RAX := SignExtend(RAX)</operation>
      <flags-affected>None</flags-affected>
      <notes>Used before IDIV to prepare dividend. Part of family: CWD (AX-&gt;DX:AX), CDQ (EAX-&gt;EDX:EAX), CQO (RAX-&gt;RDX:RAX).</notes>
    </documentation>
  </instruction>
  <instruction name="crc32" category="SIMD">
    <description>Accumulate CRC32 value</description>
  </instruction>
  <instruction name="cvtdq2pd" category="SIMD">
    <description>Convert packed dword integers to packed double-precision</description>
  </instruction>
  <instruction name="cvtdq2ps" category="SIMD">
    <description>Convert packed dword integers to packed single-precision</description>
  </instruction>
  <instruction name="cvtpd2dq" category="SIMD">
    <description>Convert packed double-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvtpd2pi" category="SIMD">
    <description>Convert packed double-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvtpd2ps" category="SIMD">
    <description>Convert packed double-precision to packed single-precision</description>
  </instruction>
  <instruction name="cvtpi2pd" category="SIMD">
    <description>Convert packed dword integers to packed double-precision</description>
  </instruction>
  <instruction name="cvtpi2ps" category="SIMD">
    <description>Convert packed dword integers to packed single-precision</description>
  </instruction>
  <instruction name="cvtps2dq" category="SIMD">
    <description>Convert packed single-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvtps2pd" category="SIMD">
    <description>Convert packed single-precision to packed double-precision</description>
  </instruction>
  <instruction name="cvtps2pi" category="SIMD">
    <description>Convert packed single-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvtsd2si" category="SIMD">
    <description>Convert scalar double-precision to dword integer</description>
  </instruction>
  <instruction name="cvtsd2ss" category="SIMD">
    <description>Convert scalar double-precision to scalar single-precision</description>
  </instruction>
  <instruction name="cvtsi2sd" category="SIMD">
    <description>Convert dword integer to scalar double-precision</description>
  </instruction>
  <instruction name="cvtsi2ss" category="SIMD">
    <description>Convert dword integer to scalar single-precision</description>
  </instruction>
  <instruction name="cvtss2sd" category="SIMD">
    <description>Convert scalar single-precision to scalar double-precision</description>
  </instruction>
  <instruction name="cvtss2si" category="SIMD">
    <description>Convert scalar single-precision to dword integer</description>
  </instruction>
  <instruction name="cvttpd2dq" category="SIMD">
    <description>Convert with truncation packed double-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvttpd2pi" category="SIMD">
    <description>Convert with truncation packed double-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvttps2dq" category="SIMD">
    <description>Convert with truncation packed single-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvttps2pi" category="SIMD">
    <description>Convert with truncation packed single-precision to packed dword integers</description>
  </instruction>
  <instruction name="cvttsd2si" category="SIMD">
    <description>Convert with truncation scalar double-precision to dword integer</description>
  </instruction>
  <instruction name="cvttss2si" category="SIMD">
    <description>Convert with truncation scalar single-precision to dword integer</description>
  </instruction>
  <instruction name="cwd" category="CONVERSION">
    <description>Convert word to doubleword</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Convert Word to Doubleword</summary>
      <description>Sign-extends the word in AX to fill DX:AX.</description>
      <operation>DX:AX := SignExtend(AX)</operation>
      <flags-affected>None</flags-affected>
      <notes>Used before IDIV to prepare dividend. Part of family: CWD (AX-&gt;DX:AX), CDQ (EAX-&gt;EDX:EAX), CQO (RAX-&gt;RDX:RAX).</notes>
    </documentation>
  </instruction>
  <instruction name="cwde" category="CONVERSION">
    <description>Convert word to doubleword</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Convert Word to Doubleword Extended</summary>
      <description>Sign-extends the word in AX to fill EAX.</description>
      <operation>EAX := SignExtend(AX)</operation>
      <flags-affected>None</flags-affected>
      <notes>Part of the sign extension family: CBW (AL-&gt;AX), CWDE (AX-&gt;EAX), CDQE (EAX-&gt;RAX).</notes>
    </documentation>
  </instruction>
  <instruction name="daa" category="ARITHMETIC">
    <description>Decimal adjust after addition</description>
  </instruction>
  <instruction name="das" category="ARITHMETIC">
    <description>Decimal adjust after subtraction</description>
  </instruction>
  <instruction name="dec" category="ARITHMETIC">
    <description>Decrement</description>
    <documentation>
      <summary>Decrement by 1</summary>
      <description>Subtracts 1 from the destination operand. The destination operand can be a register or memory location.</description>
      <operation>DEST := DEST - 1</operation>
      <flags-affected>OF, SF, ZF, AF, PF (CF not affected)</flags-affected>
      <notes>The CF flag is not affected.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="div" category="ARITHMETIC">
    <description>Unsigned divide</description>
    <documentation>
      <summary>Unsigned Divide</summary>
      <description>Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers.</description>
      <operation>if operand size is 8:
  AL := AX / SRC; AH := AX % SRC
else if operand size is 16:
  AX := DX:AX / SRC; DX := DX:AX % SRC
else if operand size is 32:
  EAX := EDX:EAX / SRC; EDX := EDX:EAX % SRC
else if operand size is 64:
  RAX := RDX:RAX / SRC; RDX := RDX:RAX % SRC</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF (all undefined)</flags-affected>
      <notes>Generates #DE (divide error) if divisor is 0 or if quotient is too large for destination.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="divpd" category="SIMD">
    <description>Divide packed double-precision</description>
  </instruction>
  <instruction name="divps" category="SIMD">
    <description>Divide packed single-precision</description>
  </instruction>
  <instruction name="divsd" category="SIMD">
    <description>Divide scalar double-precision</description>
  </instruction>
  <instruction name="divss" category="SIMD">
    <description>Divide scalar single-precision</description>
  </instruction>
  <instruction name="dppd" category="SIMD">
    <description>Dot product of packed double-precision</description>
  </instruction>
  <instruction name="dpps" category="SIMD">
    <description>Dot product of packed single-precision</description>
  </instruction>
  <instruction name="emms" category="SIMD">
    <description>Empty MMX state</description>
  </instruction>
  <instruction name="enter" category="CONTROL_FLOW">
    <description>High level procedure entry</description>
    <variants>
      <variant>
        <operand type="IMM16" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Make Stack Frame for Procedure Parameters</summary>
      <description>Creates a stack frame for a procedure. Pushes RBP, copies RSP to RBP, and allocates space for local variables.</description>
      <operation>push(RBP)
RBP := RSP
RSP := RSP - imm16</operation>
      <flags-affected>None</flags-affected>
      <notes>First operand specifies local variable space. Second operand specifies nesting level (usually 0).</notes>
    </documentation>
  </instruction>
  <instruction name="extractps" category="SIMD">
    <description>Extract packed single-precision</description>
  </instruction>
  <instruction name="f2xm1" category="FLOATING_POINT">
    <description>2^x - 1</description>
  </instruction>
  <instruction name="fabs" category="FLOATING_POINT">
    <description>Absolute value</description>
  </instruction>
  <instruction name="fadd" category="FLOATING_POINT">
    <description>Add floating point</description>
  </instruction>
  <instruction name="faddp" category="FLOATING_POINT">
    <description>Add floating point and pop</description>
  </instruction>
  <instruction name="fbld" category="FLOATING_POINT">
    <description>Load binary coded decimal</description>
  </instruction>
  <instruction name="fbstp" category="FLOATING_POINT">
    <description>Store binary coded decimal and pop</description>
  </instruction>
  <instruction name="fchs" category="FLOATING_POINT">
    <description>Change sign</description>
  </instruction>
  <instruction name="fclex" category="FLOATING_POINT">
    <description>Clear exceptions</description>
  </instruction>
  <instruction name="fcom" category="FLOATING_POINT">
    <description>Compare floating point</description>
  </instruction>
  <instruction name="fcomi" category="FLOATING_POINT">
    <description>Compare floating point and set EFLAGS</description>
  </instruction>
  <instruction name="fcomip" category="FLOATING_POINT">
    <description>Compare floating point, set EFLAGS, and pop</description>
  </instruction>
  <instruction name="fcomp" category="FLOATING_POINT">
    <description>Compare floating point and pop</description>
  </instruction>
  <instruction name="fcompp" category="FLOATING_POINT">
    <description>Compare floating point and pop twice</description>
  </instruction>
  <instruction name="fcos" category="FLOATING_POINT">
    <description>Cosine</description>
  </instruction>
  <instruction name="fdecstp" category="FLOATING_POINT">
    <description>Decrement stack-top pointer</description>
  </instruction>
  <instruction name="fdiv" category="FLOATING_POINT">
    <description>Divide floating point</description>
  </instruction>
  <instruction name="fdivp" category="FLOATING_POINT">
    <description>Divide floating point and pop</description>
  </instruction>
  <instruction name="fdivr" category="FLOATING_POINT">
    <description>Reverse divide floating point</description>
  </instruction>
  <instruction name="fdivrp" category="FLOATING_POINT">
    <description>Reverse divide floating point and pop</description>
  </instruction>
  <instruction name="ffree" category="FLOATING_POINT">
    <description>Free floating point register</description>
  </instruction>
  <instruction name="ffreep" category="FLOATING_POINT">
    <description>Free floating point register and pop</description>
  </instruction>
  <instruction name="fiadd" category="FLOATING_POINT">
    <description>Add integer</description>
  </instruction>
  <instruction name="ficom" category="FLOATING_POINT">
    <description>Compare integer</description>
  </instruction>
  <instruction name="ficomp" category="FLOATING_POINT">
    <description>Compare integer and pop</description>
  </instruction>
  <instruction name="fidiv" category="FLOATING_POINT">
    <description>Divide integer</description>
  </instruction>
  <instruction name="fidivr" category="FLOATING_POINT">
    <description>Reverse divide integer</description>
  </instruction>
  <instruction name="fild" category="FLOATING_POINT">
    <description>Load integer</description>
  </instruction>
  <instruction name="fimul" category="FLOATING_POINT">
    <description>Multiply integer</description>
  </instruction>
  <instruction name="fincstp" category="FLOATING_POINT">
    <description>Increment stack-top pointer</description>
  </instruction>
  <instruction name="finit" category="FLOATING_POINT">
    <description>Initialize floating point unit</description>
  </instruction>
  <instruction name="fist" category="FLOATING_POINT">
    <description>Store integer</description>
  </instruction>
  <instruction name="fistp" category="FLOATING_POINT">
    <description>Store integer and pop</description>
  </instruction>
  <instruction name="fisttp" category="FLOATING_POINT">
    <description>Store integer with truncation and pop</description>
  </instruction>
  <instruction name="fisub" category="FLOATING_POINT">
    <description>Subtract integer</description>
  </instruction>
  <instruction name="fisubr" category="FLOATING_POINT">
    <description>Reverse subtract integer</description>
  </instruction>
  <instruction name="fld" category="FLOATING_POINT">
    <description>Load floating point value</description>
  </instruction>
  <instruction name="fld1" category="FLOATING_POINT">
    <description>Load +1.0</description>
  </instruction>
  <instruction name="fldcw" category="FLOATING_POINT">
    <description>Load control word</description>
  </instruction>
  <instruction name="fldenv" category="FLOATING_POINT">
    <description>Load FPU environment</description>
  </instruction>
  <instruction name="fldl2e" category="FLOATING_POINT">
    <description>Load log2(e)</description>
  </instruction>
  <instruction name="fldl2t" category="FLOATING_POINT">
    <description>Load log2(10)</description>
  </instruction>
  <instruction name="fldlg2" category="FLOATING_POINT">
    <description>Load log10(2)</description>
  </instruction>
  <instruction name="fldln2" category="FLOATING_POINT">
    <description>Load ln(2)</description>
  </instruction>
  <instruction name="fldpi" category="FLOATING_POINT">
    <description>Load π</description>
  </instruction>
  <instruction name="fldz" category="FLOATING_POINT">
    <description>Load +0.0</description>
  </instruction>
  <instruction name="fmul" category="FLOATING_POINT">
    <description>Multiply floating point</description>
  </instruction>
  <instruction name="fmulp" category="FLOATING_POINT">
    <description>Multiply floating point and pop</description>
  </instruction>
  <instruction name="fnclex" category="FLOATING_POINT">
    <description>Clear exceptions (no wait)</description>
  </instruction>
  <instruction name="fninit" category="FLOATING_POINT">
    <description>Initialize floating point unit (no wait)</description>
  </instruction>
  <instruction name="fnop" category="FLOATING_POINT">
    <description>No operation</description>
  </instruction>
  <instruction name="fnsave" category="FLOATING_POINT">
    <description>Save FPU state (no wait)</description>
  </instruction>
  <instruction name="fnstcw" category="FLOATING_POINT">
    <description>Store control word (no wait)</description>
  </instruction>
  <instruction name="fnstenv" category="FLOATING_POINT">
    <description>Store FPU environment (no wait)</description>
  </instruction>
  <instruction name="fnstsw" category="FLOATING_POINT">
    <description>Store status word (no wait)</description>
  </instruction>
  <instruction name="fpatan" category="FLOATING_POINT">
    <description>Partial arctangent</description>
  </instruction>
  <instruction name="fprem" category="FLOATING_POINT">
    <description>Partial remainder</description>
  </instruction>
  <instruction name="fprem1" category="FLOATING_POINT">
    <description>IEEE partial remainder</description>
  </instruction>
  <instruction name="fptan" category="FLOATING_POINT">
    <description>Partial tangent</description>
  </instruction>
  <instruction name="frndint" category="FLOATING_POINT">
    <description>Round to integer</description>
  </instruction>
  <instruction name="frstor" category="FLOATING_POINT">
    <description>Restore FPU state</description>
  </instruction>
  <instruction name="fsave" category="FLOATING_POINT">
    <description>Save FPU state</description>
  </instruction>
  <instruction name="fscale" category="FLOATING_POINT">
    <description>Scale by power of 2</description>
  </instruction>
  <instruction name="fsin" category="FLOATING_POINT">
    <description>Sine</description>
  </instruction>
  <instruction name="fsincos" category="FLOATING_POINT">
    <description>Sine and cosine</description>
  </instruction>
  <instruction name="fsqrt" category="FLOATING_POINT">
    <description>Square root</description>
  </instruction>
  <instruction name="fst" category="FLOATING_POINT">
    <description>Store floating point value</description>
  </instruction>
  <instruction name="fstcw" category="FLOATING_POINT">
    <description>Store control word</description>
  </instruction>
  <instruction name="fstenv" category="FLOATING_POINT">
    <description>Store FPU environment</description>
  </instruction>
  <instruction name="fstp" category="FLOATING_POINT">
    <description>Store floating point value and pop</description>
  </instruction>
  <instruction name="fstsw" category="FLOATING_POINT">
    <description>Store status word</description>
  </instruction>
  <instruction name="fsub" category="FLOATING_POINT">
    <description>Subtract floating point</description>
  </instruction>
  <instruction name="fsubp" category="FLOATING_POINT">
    <description>Subtract floating point and pop</description>
  </instruction>
  <instruction name="fsubr" category="FLOATING_POINT">
    <description>Reverse subtract floating point</description>
  </instruction>
  <instruction name="fsubrp" category="FLOATING_POINT">
    <description>Reverse subtract floating point and pop</description>
  </instruction>
  <instruction name="ftst" category="FLOATING_POINT">
    <description>Test (compare with 0.0)</description>
  </instruction>
  <instruction name="fucom" category="FLOATING_POINT">
    <description>Unordered compare floating point</description>
  </instruction>
  <instruction name="fucomi" category="FLOATING_POINT">
    <description>Unordered compare floating point and set EFLAGS</description>
  </instruction>
  <instruction name="fucomip" category="FLOATING_POINT">
    <description>Unordered compare floating point, set EFLAGS, and pop</description>
  </instruction>
  <instruction name="fucomp" category="FLOATING_POINT">
    <description>Unordered compare floating point and pop</description>
  </instruction>
  <instruction name="fucompp" category="FLOATING_POINT">
    <description>Unordered compare floating point and pop twice</description>
  </instruction>
  <instruction name="fwait" category="SYSTEM">
    <description>Wait for FPU (alias)</description>
  </instruction>
  <instruction name="fxam" category="FLOATING_POINT">
    <description>Examine floating point</description>
  </instruction>
  <instruction name="fxch" category="FLOATING_POINT">
    <description>Exchange register contents</description>
  </instruction>
  <instruction name="fxrstor" category="FLOATING_POINT">
    <description>Restore x87 FPU, MMX, and SSE state</description>
  </instruction>
  <instruction name="fxrstor64" category="FLOATING_POINT">
    <description>Restore x87 FPU, MMX, and SSE state (64-bit)</description>
  </instruction>
  <instruction name="fxsave" category="FLOATING_POINT">
    <description>Save x87 FPU, MMX, and SSE state</description>
  </instruction>
  <instruction name="fxsave64" category="FLOATING_POINT">
    <description>Save x87 FPU, MMX, and SSE state (64-bit)</description>
  </instruction>
  <instruction name="fxtract" category="FLOATING_POINT">
    <description>Extract exponent and significand</description>
  </instruction>
  <instruction name="fyl2x" category="FLOATING_POINT">
    <description>Y * log2(X)</description>
  </instruction>
  <instruction name="fyl2xp1" category="FLOATING_POINT">
    <description>Y * log2(X+1)</description>
  </instruction>
  <instruction name="haddpd" category="SIMD">
    <description>Horizontal add packed double-precision</description>
  </instruction>
  <instruction name="haddps" category="SIMD">
    <description>Horizontal add packed single-precision</description>
  </instruction>
  <instruction name="hlt" category="SYSTEM">
    <description>Halt</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Halt</summary>
      <description>Stops instruction execution and places the processor in a HALT state. The processor will remain halted until an external interrupt or reset occurs. This instruction is privileged (CPL=0).</description>
      <operation>(processor enters HALT state)</operation>
      <flags-affected>None</flags-affected>
      <notes>Privileged instruction. Used to idle the CPU until the next interrupt.</notes>
    </documentation>
  </instruction>
  <instruction name="hsubpd" category="SIMD">
    <description>Horizontal subtract packed double-precision</description>
  </instruction>
  <instruction name="hsubps" category="SIMD">
    <description>Horizontal subtract packed single-precision</description>
  </instruction>
  <instruction name="idiv" category="ARITHMETIC">
    <description>Signed divide</description>
    <documentation>
      <summary>Signed Divide</summary>
      <description>Divides the signed value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers.</description>
      <operation>if operand size is 8:
  AL := AX / SRC; AH := AX % SRC
else if operand size is 16:
  AX := DX:AX / SRC; DX := DX:AX % SRC
else if operand size is 32:
  EAX := EDX:EAX / SRC; EDX := EDX:EAX % SRC
else if operand size is 64:
  RAX := RDX:RAX / SRC; RDX := RDX:RAX % SRC</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF (all undefined)</flags-affected>
      <notes>Generates #DE (divide error) if divisor is 0 or if quotient is too large for destination. Truncates toward 0.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="imul" category="ARITHMETIC">
    <description>Signed multiply</description>
    <documentation>
      <summary>Signed Multiply</summary>
      <description>Performs a signed multiplication of the source operand and the accumulator or two specified operands.</description>
      <operation>DEST := DEST * SRC</operation>
      <flags-affected>OF, CF (SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Has multiple forms: one-operand (implicit accumulator), two-operand, and three-operand.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
        <operand type="IMM" />
      </variant>
    </variants>
  </instruction>
  <instruction name="in" category="IO">
    <description>Input from port</description>
    <variants>
      <variant>
        <operand type="AL" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="AX" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="EAX" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="AL" />
        <operand type="DX" />
      </variant>
      <variant>
        <operand type="AX" />
        <operand type="DX" />
      </variant>
      <variant>
        <operand type="EAX" />
        <operand type="DX" />
      </variant>
    </variants>
    <documentation>
      <summary>Input from Port</summary>
      <description>Reads data from the specified I/O port into the accumulator register (AL, AX, or EAX). This instruction is privileged if CPL &gt; IOPL or if I/O permission bitmap denies access.</description>
      <operation>AL/AX/EAX := IOPort[port]</operation>
      <flags-affected>None</flags-affected>
      <notes>Port number can be immediate (0-255) or in DX (0-65535). May be privileged depending on IOPL and I/O permission bitmap.</notes>
    </documentation>
  </instruction>
  <instruction name="inc" category="ARITHMETIC">
    <description>Increment</description>
    <documentation>
      <summary>Increment by 1</summary>
      <description>Adds 1 to the destination operand. The destination operand can be a register or memory location.</description>
      <operation>DEST := DEST + 1</operation>
      <flags-affected>OF, SF, ZF, AF, PF (CF not affected)</flags-affected>
      <notes>The CF flag is not affected.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="ins" category="IO">
    <description>Input string from port</description>
  </instruction>
  <instruction name="insb" category="IO">
    <description>Input byte string from port</description>
  </instruction>
  <instruction name="insd" category="IO">
    <description>Input doubleword string from port</description>
  </instruction>
  <instruction name="insertps" category="SIMD">
    <description>Insert packed single-precision</description>
  </instruction>
  <instruction name="insw" category="IO">
    <description>Input word string from port</description>
  </instruction>
  <instruction name="int" category="SYSTEM">
    <description>Call interrupt</description>
    <variants>
      <variant>
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="IMM3" />
      </variant>
    </variants>
    <documentation>
      <summary>Call to Interrupt Procedure</summary>
      <description>Generates a software interrupt by calling the interrupt handler at the specified interrupt vector.</description>
      <operation>push(RFLAGS)
push(CS)
push(RIP)
RIP := InterruptVector[imm8]</operation>
      <flags-affected>IF, TF, AC (others saved on stack)</flags-affected>
      <notes>INT 3 is a special one-byte form used for breakpoints. INT 0x80 is the legacy Linux system call.</notes>
    </documentation>
  </instruction>
  <instruction name="int3" category="SYSTEM">
    <description>Breakpoint interrupt</description>
  </instruction>
  <instruction name="into" category="SYSTEM">
    <description>Interrupt on overflow</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Interrupt on overflow</summary>
      <description>The INTO instruction checks the Overflow Flag (OF) in the EFLAGS register and generates an overflow exception (interrupt vector 4) if OF=1, calling the overflow exception handler. When the interrupt occurs, the EFLAGS register is pushed onto the stack and certain flags may be cleared depending on processor mode.</description>
      <operation>IF OF = 1 THEN
  Generate INT 4 (overflow exception)</operation>
      <flags-affected>Reads OF; when interrupt occurs, IF, TF, NT, VM, RF may be cleared depending on mode</flags-affected>
      <notes>Invalid in 64-bit mode (generates #UD exception if attempted). Valid only in Compatibility and Legacy modes. Provides a compact way to handle arithmetic overflow conditions.</notes>
    </documentation>
  </instruction>
  <instruction name="invd" category="SYSTEM">
    <description>Invalidate internal caches</description>
  </instruction>
  <instruction name="invlpg" category="SYSTEM">
    <description>Invalidate TLB entry</description>
  </instruction>
  <instruction name="invpcid" category="SYSTEM">
    <description>Invalidate process-context identifier</description>
  </instruction>
  <instruction name="iret" category="SYSTEM">
    <description>Return from interrupt</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Interrupt Return</summary>
      <description>Returns from an interrupt handler. Pops RIP, CS, and RFLAGS from the stack.</description>
      <operation>pop(RIP)
pop(CS)
pop(RFLAGS)</operation>
      <flags-affected>All flags (restored from stack)</flags-affected>
      <notes>Privileged instruction. In 64-bit mode, use IRETQ.</notes>
    </documentation>
  </instruction>
  <instruction name="iretd" category="SYSTEM">
    <description>Return from interrupt (32-bit)</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Interrupt return (32-bit mode)</summary>
      <description>The IRETD instruction returns program control from an interrupt or exception handler by restoring the instruction pointer, code segment selector, and EFLAGS register from the stack. It handles multiple return scenarios including returns from different privilege levels, virtual-8086 mode, and protected mode with extensive validation and state restoration.</description>
      <operation>EIP := Pop()
CS := Pop()
EFLAGS := Pop()</operation>
      <flags-affected>All EFLAGS fields potentially modified (restored from stack)</flags-affected>
      <notes>In protected mode, handles intra/inter-privilege level returns and returns from virtual-8086 mode. This is a serializing instruction that unblocks nonmaskable interrupts (NMIs). In 64-bit mode, default operation size is 32 bits.</notes>
    </documentation>
  </instruction>
  <instruction name="iretq" category="SYSTEM">
    <description>Return from interrupt (64-bit)</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Interrupt return (64-bit mode)</summary>
      <description>The IRETQ instruction is the 64-bit variant of interrupt return that restores the instruction pointer, code segment selector, and RFLAGS register from the stack. It requires the REX.W prefix and handles 64-bit return addresses with canonical address checking and privilege level transitions specific to 64-bit mode operation.</description>
      <operation>RIP := Pop()
CS := Pop()
RFLAGS := Pop()</operation>
      <flags-affected>All RFLAGS fields potentially modified (restored from stack)</flags-affected>
      <notes>Requires REX.W prefix for 64-bit operation. Cannot execute with Nested Task (NT) flag set in 64-bit mode. Performs more stringent canonical address checks than 32-bit mode. This is a serializing instruction that unblocks nonmaskable interrupts (NMIs).</notes>
    </documentation>
  </instruction>
  <instruction name="ja" category="CONTROL_FLOW">
    <description>Jump if above (unsigned)</description>
    <documentation>
      <summary>Jump if Above / Jump if Not Below or Equal</summary>
      <description>Checks the state of the CF and ZF flags. If CF=0 and ZF=0, a jump is performed. Used for unsigned comparisons.</description>
      <operation>if CF = 0 AND ZF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use JG for signed comparisons.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="LABEL" />
      </variant>
    </variants>
  </instruction>
  <instruction name="jae" category="CONTROL_FLOW">
    <description>Jump if above or equal (unsigned)</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Above or Equal / Jump if Not Below / Jump if Not Carry</summary>
      <description>Checks the state of the CF flag. If CF=0, a jump is performed. Used for unsigned comparisons.</description>
      <operation>if CF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use JGE for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jb" category="CONTROL_FLOW">
    <description>Jump if below (unsigned)</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Below / Jump if Not Above or Equal / Jump if Carry</summary>
      <description>Checks the state of the CF flag. If CF=1, a jump is performed. Used for unsigned comparisons.</description>
      <operation>if CF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use JL for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jbe" category="CONTROL_FLOW">
    <description>Jump if below or equal (unsigned)</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Below or Equal / Jump if Not Above</summary>
      <description>Checks the state of the CF and ZF flags. If CF=1 or ZF=1, a jump is performed. Used for unsigned comparisons.</description>
      <operation>if CF = 1 OR ZF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use JLE for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jc" category="CONTROL_FLOW">
    <description>Jump if carry</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if carry</summary>
      <description>Jumps to the target instruction specified by the operand if the Carry Flag (CF) is set to 1. This instruction is used to detect carries from arithmetic operations or to check if an unsigned comparison resulted in a "below" condition. JC is an alias for JB (Jump if Below) and JNAE (Jump if Not Above or Equal).</description>
      <operation>IF CF = 1 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>JC, JB, and JNAE are alternate mnemonics for the same opcode. The condition tested is CF = 1.</notes>
    </documentation>
  </instruction>
  <instruction name="jcxz" category="CONTROL_FLOW">
    <description>Jump if CX is zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if CX register is zero</summary>
      <description>Jumps to the target instruction specified by the operand if the CX register contains zero. Unlike other conditional jump instructions, JCXZ does not check status flags but instead tests the value of the CX register directly. This instruction is useful at the beginning of a loop to prevent entering when the counter is already zero.</description>
      <operation>IF CX = 0 THEN
  RIP := RIP + SignExtend(rel8)</operation>
      <flags-affected>None (tests CX register)</flags-affected>
      <notes>Only supports short jumps (±128 bytes). In 64-bit mode, requires address-size prefix. The address-size attribute determines which register is tested.</notes>
    </documentation>
  </instruction>
  <instruction name="je" category="CONTROL_FLOW">
    <description>Jump if equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Equal / Jump if Zero</summary>
      <description>Checks the state of the ZF flag. If ZF=1, a jump to the target instruction is performed.</description>
      <operation>if ZF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>JE and JZ are synonyms. Typically used after CMP instruction.</notes>
    </documentation>
  </instruction>
  <instruction name="jecxz" category="CONTROL_FLOW">
    <description>Jump if ECX is zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if ECX register is zero</summary>
      <description>Jumps to the target instruction specified by the operand if the ECX register contains zero. Unlike other conditional jump instructions, JECXZ does not check status flags but instead tests the value of the ECX register directly. This instruction is useful at the beginning of a loop to prevent entering when the counter is already zero.</description>
      <operation>IF ECX = 0 THEN
  RIP := RIP + SignExtend(rel8)</operation>
      <flags-affected>None (tests ECX register)</flags-affected>
      <notes>Only supports short jumps (±128 bytes). In 64-bit mode, requires address-size prefix (67h). The address-size attribute determines which register is tested.</notes>
    </documentation>
  </instruction>
  <instruction name="jg" category="CONTROL_FLOW">
    <description>Jump if greater</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Greater / Jump if Not Less or Equal</summary>
      <description>Checks the state of the ZF and SF flags. If (SF XOR OF)=0 and ZF=0, a jump to the target instruction is performed. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 0 AND ZF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use JA for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jge" category="CONTROL_FLOW">
    <description>Jump if greater or equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Greater or Equal / Jump if Not Less</summary>
      <description>Checks the state of the SF and OF flags. If (SF XOR OF)=0, a jump is performed. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use JAE for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jl" category="CONTROL_FLOW">
    <description>Jump if less</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Less / Jump if Not Greater or Equal</summary>
      <description>Checks the state of the SF and OF flags. If (SF XOR OF)=1, a jump to the target instruction is performed. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use JB for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jle" category="CONTROL_FLOW">
    <description>Jump if less or equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Less or Equal / Jump if Not Greater</summary>
      <description>Checks the state of the ZF, SF, and OF flags. If (SF XOR OF)=1 or ZF=1, a jump is performed. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 1 OR ZF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use JBE for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="jmp" category="CONTROL_FLOW">
    <description>Unconditional jump</description>
    <documentation>
      <summary>Jump</summary>
      <description>Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to.</description>
      <operation>RIP := target</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be short (8-bit offset), near (16/32-bit offset), or far (segment:offset).</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="LABEL" />
      </variant>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="jmpe" category="SYSTEM">
    <description>Jump to IA-64 instruction set</description>
  </instruction>
  <instruction name="jna" category="CONTROL_FLOW">
    <description>Jump if not above</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not above (unsigned &lt;=)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of an unsigned comparison indicates "not above" (less than or equal). This instruction checks if either the Carry Flag (CF) is set or the Zero Flag (ZF) is set. It is commonly used after a CMP instruction to perform unsigned comparisons. JNA is an alias for JBE (Jump if Below or Equal).</description>
      <operation>IF (CF = 1 OR ZF = 1) THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads CF and ZF)</flags-affected>
      <notes>JNA and JBE are alternate mnemonics for the same opcode. The condition tested is CF = 1 or ZF = 1.</notes>
    </documentation>
  </instruction>
  <instruction name="jnae" category="CONTROL_FLOW">
    <description>Jump if not above or equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not above or equal (unsigned &lt;)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of an unsigned comparison indicates "not above or equal" (less than). This instruction checks if the Carry Flag (CF) is set. It is commonly used after a CMP instruction to perform unsigned comparisons. JNAE is an alias for JB (Jump if Below) and JC (Jump if Carry).</description>
      <operation>IF CF = 1 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>JNAE, JB, and JC are alternate mnemonics for the same opcode. The condition tested is CF = 1.</notes>
    </documentation>
  </instruction>
  <instruction name="jnb" category="CONTROL_FLOW">
    <description>Jump if not below</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not below (unsigned &gt;=)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of an unsigned comparison indicates "not below" (greater than or equal). This instruction checks if the Carry Flag (CF) is cleared to 0. It is commonly used after a CMP instruction to perform unsigned comparisons. JNB is an alias for JAE (Jump if Above or Equal) and JNC (Jump if Not Carry).</description>
      <operation>IF CF = 0 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>JNB, JAE, and JNC are alternate mnemonics for the same opcode. The condition tested is CF = 0.</notes>
    </documentation>
  </instruction>
  <instruction name="jnbe" category="CONTROL_FLOW">
    <description>Jump if not below or equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not below or equal (unsigned &gt;)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of an unsigned comparison indicates "not below or equal" (greater than). This instruction checks if both the Carry Flag (CF) and Zero Flag (ZF) are cleared to 0. It is commonly used after a CMP instruction to perform unsigned comparisons. JNBE is an alias for JA (Jump if Above).</description>
      <operation>IF (CF = 0 AND ZF = 0) THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads CF and ZF)</flags-affected>
      <notes>JNBE and JA are alternate mnemonics for the same opcode. The condition tested is CF = 0 and ZF = 0.</notes>
    </documentation>
  </instruction>
  <instruction name="jnc" category="CONTROL_FLOW">
    <description>Jump if not carry</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not carry</summary>
      <description>Jumps to the target instruction specified by the operand if the Carry Flag (CF) is cleared to 0. This instruction is used to check for no carry from arithmetic operations or to verify that an unsigned comparison resulted in an "above or equal" condition. JNC is an alias for JNB (Jump if Not Below) and JAE (Jump if Above or Equal).</description>
      <operation>IF CF = 0 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>JNC, JNB, and JAE are alternate mnemonics for the same opcode. The condition tested is CF = 0.</notes>
    </documentation>
  </instruction>
  <instruction name="jne" category="CONTROL_FLOW">
    <description>Jump if not equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Not Equal / Jump if Not Zero</summary>
      <description>Checks the state of the ZF flag. If ZF=0, a jump to the target instruction is performed.</description>
      <operation>if ZF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>JNE and JNZ are synonyms. Typically used after CMP instruction.</notes>
    </documentation>
  </instruction>
  <instruction name="jng" category="CONTROL_FLOW">
    <description>Jump if not greater</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not greater (signed &lt;=)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of a signed comparison indicates "not greater" (less than or equal). This instruction checks if the Zero Flag (ZF) is set or if the Sign Flag (SF) differs from the Overflow Flag (OF). It is commonly used after a CMP instruction to perform signed comparisons. JNG is an alias for JLE (Jump if Less or Equal).</description>
      <operation>IF (ZF = 1 OR SF ≠ OF) THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads ZF, SF, and OF)</flags-affected>
      <notes>JNG and JLE are alternate mnemonics for the same opcode. The condition tested is ZF = 1 or SF ≠ OF.</notes>
    </documentation>
  </instruction>
  <instruction name="jnge" category="CONTROL_FLOW">
    <description>Jump if not greater or equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not greater or equal (signed &lt;)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of a signed comparison indicates "not greater or equal" (less than). This instruction checks if the Sign Flag (SF) differs from the Overflow Flag (OF). It is commonly used after a CMP instruction to perform signed comparisons. JNGE is an alias for JL (Jump if Less).</description>
      <operation>IF SF ≠ OF THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads SF and OF)</flags-affected>
      <notes>JNGE and JL are alternate mnemonics for the same opcode. The condition tested is SF ≠ OF.</notes>
    </documentation>
  </instruction>
  <instruction name="jnl" category="CONTROL_FLOW">
    <description>Jump if not less</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not less (signed &gt;=)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of a signed comparison indicates "not less" (greater than or equal). This instruction checks if the Sign Flag (SF) equals the Overflow Flag (OF). It is commonly used after a CMP instruction to perform signed comparisons. JNL is an alias for JGE (Jump if Greater or Equal).</description>
      <operation>IF SF = OF THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads SF and OF)</flags-affected>
      <notes>JNL and JGE are alternate mnemonics for the same opcode. The condition tested is SF = OF.</notes>
    </documentation>
  </instruction>
  <instruction name="jnle" category="CONTROL_FLOW">
    <description>Jump if not less or equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not less or equal (signed &gt;)</summary>
      <description>Jumps to the target instruction specified by the operand if the result of a signed comparison indicates "not less or equal" (greater than). This instruction checks if the Zero Flag (ZF) is cleared and the Sign Flag (SF) equals the Overflow Flag (OF). It is commonly used after a CMP instruction to perform signed comparisons. JNLE is an alias for JG (Jump if Greater).</description>
      <operation>IF (ZF = 0 AND SF = OF) THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads ZF, SF, and OF)</flags-affected>
      <notes>JNLE and JG are alternate mnemonics for the same opcode. The condition tested is ZF = 0 and SF = OF.</notes>
    </documentation>
  </instruction>
  <instruction name="jno" category="CONTROL_FLOW">
    <description>Jump if not overflow</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Not Overflow</summary>
      <description>Checks the state of the OF flag. If OF=0, a jump is performed.</description>
      <operation>if OF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Jumps if the last arithmetic operation did not result in overflow.</notes>
    </documentation>
  </instruction>
  <instruction name="jnp" category="CONTROL_FLOW">
    <description>Jump if not parity</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Not Parity / Jump if Parity Odd</summary>
      <description>Checks the state of the PF flag. If PF=0, a jump is performed.</description>
      <operation>if PF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Jumps if the number of set bits in the low byte of the result is odd.</notes>
    </documentation>
  </instruction>
  <instruction name="jns" category="CONTROL_FLOW">
    <description>Jump if not sign</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Not Sign</summary>
      <description>Checks the state of the SF flag. If SF=0, a jump is performed.</description>
      <operation>if SF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Jumps if the result of the last operation was positive or zero.</notes>
    </documentation>
  </instruction>
  <instruction name="jnz" category="CONTROL_FLOW">
    <description>Jump if not zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if not zero (jump if not equal)</summary>
      <description>Jumps to the target instruction specified by the operand if the Zero Flag (ZF) is cleared to 0. This instruction is commonly used after a comparison or arithmetic operation to check if the result was non-zero or if two operands were not equal. JNZ is an alias for JNE (Jump if Not Equal).</description>
      <operation>IF ZF = 0 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads ZF)</flags-affected>
      <notes>JNZ and JNE are alternate mnemonics for the same opcode. The condition tested is ZF = 0.</notes>
    </documentation>
  </instruction>
  <instruction name="jo" category="CONTROL_FLOW">
    <description>Jump if overflow</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Overflow</summary>
      <description>Checks the state of the OF flag. If OF=1, a jump is performed.</description>
      <operation>if OF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Jumps if the last arithmetic operation resulted in overflow.</notes>
    </documentation>
  </instruction>
  <instruction name="jp" category="CONTROL_FLOW">
    <description>Jump if parity</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Parity / Jump if Parity Even</summary>
      <description>Checks the state of the PF flag. If PF=1, a jump is performed.</description>
      <operation>if PF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Jumps if the number of set bits in the low byte of the result is even.</notes>
    </documentation>
  </instruction>
  <instruction name="jpe" category="CONTROL_FLOW">
    <description>Jump if parity even</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if parity even</summary>
      <description>Jumps to the target instruction specified by the operand if the Parity Flag (PF) is set to 1, indicating that the low-order eight bits of the result contain an even number of 1 bits. This instruction is useful for checking data integrity or implementing error detection algorithms. JPE is an alias for JP (Jump if Parity).</description>
      <operation>IF PF = 1 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads PF)</flags-affected>
      <notes>JPE and JP are alternate mnemonics for the same opcode. The condition tested is PF = 1.</notes>
    </documentation>
  </instruction>
  <instruction name="jpo" category="CONTROL_FLOW">
    <description>Jump if parity odd</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if parity odd</summary>
      <description>Jumps to the target instruction specified by the operand if the Parity Flag (PF) is cleared to 0, indicating that the low-order eight bits of the result contain an odd number of 1 bits. This instruction is useful for checking data integrity or implementing error detection algorithms. JPO is an alias for JNP (Jump if Not Parity).</description>
      <operation>IF PF = 0 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads PF)</flags-affected>
      <notes>JPO and JNP are alternate mnemonics for the same opcode. The condition tested is PF = 0.</notes>
    </documentation>
  </instruction>
  <instruction name="jrcxz" category="CONTROL_FLOW">
    <description>Jump if RCX is zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if RCX register is zero</summary>
      <description>Jumps to the target instruction specified by the operand if the RCX register contains zero. Unlike other conditional jump instructions, JRCXZ does not check status flags but instead tests the value of the RCX register directly. This instruction is useful at the beginning of a loop in 64-bit code to prevent entering when the counter is already zero.</description>
      <operation>IF RCX = 0 THEN
  RIP := RIP + SignExtend(rel8)</operation>
      <flags-affected>None (tests RCX register)</flags-affected>
      <notes>Only supports short jumps (±128 bytes). Default in 64-bit mode without address-size prefix. Only 16-bit (JCXZ) and 64-bit (JRCXZ) variants are natively supported in 64-bit mode.</notes>
    </documentation>
  </instruction>
  <instruction name="js" category="CONTROL_FLOW">
    <description>Jump if sign</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if Sign</summary>
      <description>Checks the state of the SF flag. If SF=1, a jump is performed.</description>
      <operation>if SF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Jumps if the result of the last operation was negative.</notes>
    </documentation>
  </instruction>
  <instruction name="jz" category="CONTROL_FLOW">
    <description>Jump if zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL16" />
      </variant>
      <variant>
        <operand type="REL32" />
      </variant>
    </variants>
    <documentation>
      <summary>Jump if zero (jump if equal)</summary>
      <description>Jumps to the target instruction specified by the operand if the Zero Flag (ZF) is set to 1. This instruction is commonly used after a comparison or arithmetic operation to check if the result was zero or if two operands were equal. JZ is an alias for JE (Jump if Equal).</description>
      <operation>IF ZF = 1 THEN
  RIP := RIP + SignExtend(rel)</operation>
      <flags-affected>None (reads ZF)</flags-affected>
      <notes>JZ and JE are alternate mnemonics for the same opcode. The condition tested is ZF = 1.</notes>
    </documentation>
  </instruction>
  <instruction name="kaddb" category="SIMD">
    <description>Add byte mask registers</description>
  </instruction>
  <instruction name="kaddd" category="SIMD">
    <description>Add doubleword mask registers</description>
  </instruction>
  <instruction name="kaddq" category="SIMD">
    <description>Add quadword mask registers</description>
  </instruction>
  <instruction name="kaddw" category="SIMD">
    <description>Add word mask registers</description>
  </instruction>
  <instruction name="kandb" category="SIMD">
    <description>Bitwise AND byte mask registers</description>
  </instruction>
  <instruction name="kandd" category="SIMD">
    <description>Bitwise AND doubleword mask registers</description>
  </instruction>
  <instruction name="kandnb" category="SIMD">
    <description>Bitwise AND NOT byte mask registers</description>
  </instruction>
  <instruction name="kandnd" category="SIMD">
    <description>Bitwise AND NOT doubleword mask registers</description>
  </instruction>
  <instruction name="kandnq" category="SIMD">
    <description>Bitwise AND NOT quadword mask registers</description>
  </instruction>
  <instruction name="kandnw" category="SIMD">
    <description>Bitwise AND NOT word mask registers</description>
  </instruction>
  <instruction name="kandq" category="SIMD">
    <description>Bitwise AND quadword mask registers</description>
  </instruction>
  <instruction name="kandw" category="SIMD">
    <description>Bitwise AND word mask registers</description>
  </instruction>
  <instruction name="kmovb" category="SIMD">
    <description>Move byte mask register</description>
  </instruction>
  <instruction name="kmovd" category="SIMD">
    <description>Move doubleword mask register</description>
  </instruction>
  <instruction name="kmovq" category="SIMD">
    <description>Move quadword mask register</description>
  </instruction>
  <instruction name="kmovw" category="SIMD">
    <description>Move word mask register</description>
  </instruction>
  <instruction name="knotb" category="SIMD">
    <description>Bitwise NOT byte mask register</description>
  </instruction>
  <instruction name="knotd" category="SIMD">
    <description>Bitwise NOT doubleword mask register</description>
  </instruction>
  <instruction name="knotq" category="SIMD">
    <description>Bitwise NOT quadword mask register</description>
  </instruction>
  <instruction name="knotw" category="SIMD">
    <description>Bitwise NOT word mask register</description>
  </instruction>
  <instruction name="korb" category="SIMD">
    <description>Bitwise OR byte mask registers</description>
  </instruction>
  <instruction name="kord" category="SIMD">
    <description>Bitwise OR doubleword mask registers</description>
  </instruction>
  <instruction name="korq" category="SIMD">
    <description>Bitwise OR quadword mask registers</description>
  </instruction>
  <instruction name="korw" category="SIMD">
    <description>Bitwise OR word mask registers</description>
  </instruction>
  <instruction name="kshiftlb" category="SIMD">
    <description>Shift left byte mask register</description>
  </instruction>
  <instruction name="kshiftld" category="SIMD">
    <description>Shift left doubleword mask register</description>
  </instruction>
  <instruction name="kshiftlq" category="SIMD">
    <description>Shift left quadword mask register</description>
  </instruction>
  <instruction name="kshiftlw" category="SIMD">
    <description>Shift left word mask register</description>
  </instruction>
  <instruction name="kshiftrb" category="SIMD">
    <description>Shift right byte mask register</description>
  </instruction>
  <instruction name="kshiftrd" category="SIMD">
    <description>Shift right doubleword mask register</description>
  </instruction>
  <instruction name="kshiftrq" category="SIMD">
    <description>Shift right quadword mask register</description>
  </instruction>
  <instruction name="kshiftrw" category="SIMD">
    <description>Shift right word mask register</description>
  </instruction>
  <instruction name="ktestb" category="SIMD">
    <description>Test byte mask register</description>
  </instruction>
  <instruction name="ktestd" category="SIMD">
    <description>Test doubleword mask register</description>
  </instruction>
  <instruction name="ktestq" category="SIMD">
    <description>Test quadword mask register</description>
  </instruction>
  <instruction name="ktestw" category="SIMD">
    <description>Test word mask register</description>
  </instruction>
  <instruction name="kunpckbw" category="SIMD">
    <description>Unpack byte to word mask registers</description>
  </instruction>
  <instruction name="kunpckdq" category="SIMD">
    <description>Unpack doubleword to quadword mask registers</description>
  </instruction>
  <instruction name="kunpckwd" category="SIMD">
    <description>Unpack word to doubleword mask registers</description>
  </instruction>
  <instruction name="kxorb" category="SIMD">
    <description>Bitwise XOR byte mask registers</description>
  </instruction>
  <instruction name="kxord" category="SIMD">
    <description>Bitwise XOR doubleword mask registers</description>
  </instruction>
  <instruction name="kxorq" category="SIMD">
    <description>Bitwise XOR quadword mask registers</description>
  </instruction>
  <instruction name="kxorw" category="SIMD">
    <description>Bitwise XOR word mask registers</description>
  </instruction>
  <instruction name="lahf" category="SYSTEM">
    <description>Load flags into AH</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Load Status Flags into AH Register</summary>
      <description>Loads the SF, ZF, AF, PF, and CF flags from the RFLAGS register into the AH register.</description>
      <operation>AH := RFLAGS[SF:ZF:0:AF:0:PF:1:CF]</operation>
      <flags-affected>None</flags-affected>
      <notes>Useful for saving flag state. Bit positions: SF=7, ZF=6, AF=4, PF=2, CF=0.</notes>
    </documentation>
  </instruction>
  <instruction name="lar" category="SYSTEM">
    <description>Load access rights byte</description>
  </instruction>
  <instruction name="lddqu" category="SIMD">
    <description>Load unaligned integer 128 bits</description>
  </instruction>
  <instruction name="ldmxcsr" category="SIMD">
    <description>Load MXCSR register</description>
  </instruction>
  <instruction name="lds" category="DATA_MOVEMENT">
    <description>Load pointer using DS</description>
  </instruction>
  <instruction name="lea" category="DATA_MOVEMENT">
    <description>Load effective address</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="MEM" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="MEM" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="MEM" />
      </variant>
    </variants>
    <documentation>
      <summary>Load Effective Address</summary>
      <description>Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address specified with one of the addressing modes. The destination operand is a general-purpose register.</description>
      <operation>DEST := AddressOf(SRC)</operation>
      <flags-affected>None</flags-affected>
      <notes>LEA does not actually access memory; it only calculates the address.</notes>
    </documentation>
  </instruction>
  <instruction name="leave" category="CONTROL_FLOW">
    <description>High level procedure exit</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>High Level Procedure Exit</summary>
      <description>Releases the stack frame created by ENTER. Copies RBP to RSP, then pops RBP.</description>
      <operation>RSP := RBP
pop(RBP)</operation>
      <flags-affected>None</flags-affected>
      <notes>Equivalent to: MOV RSP, RBP; POP RBP. Commonly used at end of functions.</notes>
    </documentation>
  </instruction>
  <instruction name="les" category="DATA_MOVEMENT">
    <description>Load pointer using ES</description>
  </instruction>
  <instruction name="lfence" category="SYSTEM">
    <description>Load fence</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Load Fence</summary>
      <description>Performs a serializing operation on all load-from-memory instructions that were issued prior to the LFENCE instruction. Ensures that all previous load operations are complete before any subsequent load operation.</description>
      <operation>(serializing operation for loads)</operation>
      <flags-affected>None</flags-affected>
      <notes>Ensures ordering of load operations. Does not affect store operations.</notes>
    </documentation>
  </instruction>
  <instruction name="lfs" category="DATA_MOVEMENT">
    <description>Load pointer using FS</description>
  </instruction>
  <instruction name="lgdt" category="SYSTEM">
    <description>Load global descriptor table register</description>
    <variants>
      <variant>
        <operand type="MEM1632" />
      </variant>
      <variant>
        <operand type="MEM1664" />
      </variant>
    </variants>
    <documentation>
      <summary>Load Global Descriptor Table Register</summary>
      <description>Loads the Global Descriptor Table (GDT) register with the base address and limit specified in the source operand. This instruction is privileged (CPL=0) and can only be executed in kernel mode.</description>
      <operation>GDTR.Limit := m16
GDTR.Base := m32/m64</operation>
      <flags-affected>None</flags-affected>
      <notes>Privileged instruction. In 64-bit mode, loads a 16-bit limit and 64-bit base address.</notes>
    </documentation>
  </instruction>
  <instruction name="lgs" category="DATA_MOVEMENT">
    <description>Load pointer using GS</description>
  </instruction>
  <instruction name="lidt" category="SYSTEM">
    <description>Load interrupt descriptor table register</description>
    <variants>
      <variant>
        <operand type="MEM1632" />
      </variant>
      <variant>
        <operand type="MEM1664" />
      </variant>
    </variants>
    <documentation>
      <summary>Load Interrupt Descriptor Table Register</summary>
      <description>Loads the Interrupt Descriptor Table (IDT) register with the base address and limit specified in the source operand. This instruction is privileged (CPL=0) and can only be executed in kernel mode.</description>
      <operation>IDTR.Limit := m16
IDTR.Base := m32/m64</operation>
      <flags-affected>None</flags-affected>
      <notes>Privileged instruction. In 64-bit mode, loads a 16-bit limit and 64-bit base address.</notes>
    </documentation>
  </instruction>
  <instruction name="lldt" category="SYSTEM">
    <description>Load local descriptor table register</description>
  </instruction>
  <instruction name="lmsw" category="SYSTEM">
    <description>Load machine status word</description>
  </instruction>
  <instruction name="lock" category="SYSTEM">
    <description>Assert LOCK# signal prefix</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Assert LOCK# Signal Prefix</summary>
      <description>Causes the processor's LOCK# signal to be asserted during execution of the instruction that follows. Ensures that the processor has exclusive use of any shared memory while the signal is asserted.</description>
      <operation>(instruction executes atomically)</operation>
      <flags-affected>None</flags-affected>
      <notes>Can only prefix instructions that read-modify-write memory: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG.</notes>
    </documentation>
  </instruction>
  <instruction name="lods" category="STRING">
    <description>Load string</description>
    <variants>
      <variant>
        <operand type="MEM8" />
      </variant>
      <variant>
        <operand type="MEM16" />
      </variant>
      <variant>
        <operand type="MEM32" />
      </variant>
      <variant>
        <operand type="MEM64" />
      </variant>
    </variants>
    <documentation>
      <summary>Load string byte, word, doubleword, or quadword into AL/AX/EAX/RAX</summary>
      <description>Loads a byte, word, doubleword, or quadword from the memory location addressed by DS:(R|E)SI into the AL, AX, EAX, or RAX register respectively. After the load, the (R|E)SI register is automatically incremented or decremented based on the Direction Flag (DF). When DF=0, the register is incremented (forward); when DF=1, the register is decremented (backward).</description>
      <operation>AL/AX/EAX/RAX := [DS:(R|E)SI]
(R|E)SI := (R|E)SI +/- operand_size</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix. Source address is always DS:(R|E)SI. In 64-bit mode, uses RSI for addressing.</notes>
    </documentation>
  </instruction>
  <instruction name="lodsb" category="STRING">
    <description>Load byte string</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Load String</summary>
      <description>Loads data from the memory location pointed to by RSI into AL/AX/EAX/RAX, then increments or decrements (depending on DF) RSI.</description>
      <operation>AL/AX/EAX/RAX := [RSI]
RSI := RSI +/- size</operation>
      <flags-affected>None</flags-affected>
      <notes>Direction controlled by DF flag. Less commonly used with REP than other string instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="lodsd" category="STRING">
    <description>Load doubleword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Load string doubleword from memory into EAX register</summary>
      <description>Loads a doubleword (32-bit) from the memory location addressed by DS:(R|E)SI into the EAX register. After the load, the (R|E)SI register is automatically incremented or decremented by 4 based on the Direction Flag (DF). This is the no-operands form of the LODS instruction specifically for doubleword-sized operations.</description>
      <operation>EAX := [DS:(R|E)SI]
(R|E)SI := (R|E)SI +/- 4</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix. Uses DS:(R|E)SI as source address. Increments/decrements (R|E)SI by 4.</notes>
    </documentation>
  </instruction>
  <instruction name="lodsq" category="STRING">
    <description>Load quadword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Load string quadword from memory into RAX register</summary>
      <description>Loads a quadword (64-bit) from the memory location addressed by RSI into the RAX register. After the load, the RSI register is automatically incremented or decremented by 8 based on the Direction Flag (DF). This is the no-operands form of the LODS instruction specifically for quadword-sized operations and is only available in 64-bit mode.</description>
      <operation>RAX := [RSI]
RSI := RSI +/- 8</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix. Uses RSI as source address. Only available in 64-bit mode. Requires REX.W prefix.</notes>
    </documentation>
  </instruction>
  <instruction name="lodsw" category="STRING">
    <description>Load word string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Load string word from memory into AX register</summary>
      <description>Loads a word (16-bit) from the memory location addressed by DS:(R|E)SI into the AX register. After the load, the (R|E)SI register is automatically incremented or decremented by 2 based on the Direction Flag (DF). This is the no-operands form of the LODS instruction specifically for word-sized operations.</description>
      <operation>AX := [DS:(R|E)SI]
(R|E)SI := (R|E)SI +/- 2</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix. Uses DS:(R|E)SI as source address. Increments/decrements (R|E)SI by 2.</notes>
    </documentation>
  </instruction>
  <instruction name="loop" category="CONTROL_FLOW">
    <description>Loop</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Loop According to Counter</summary>
      <description>Decrements the count register (ECX/RCX) and jumps to the target if the count is not zero.</description>
      <operation>RCX := RCX - 1
if RCX != 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, uses RCX as counter. In 32-bit mode, uses ECX.</notes>
    </documentation>
  </instruction>
  <instruction name="loope" category="CONTROL_FLOW">
    <description>Loop if equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Loop if Equal / Loop if Zero</summary>
      <description>Decrements the count register (ECX/RCX) and jumps to the target if the count is not zero and ZF=1.</description>
      <operation>RCX := RCX - 1
if RCX != 0 AND ZF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Typically used with string comparison instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="loopne" category="CONTROL_FLOW">
    <description>Loop if not equal</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Loop if Not Equal / Loop if Not Zero</summary>
      <description>Decrements the count register (ECX/RCX) and jumps to the target if the count is not zero and ZF=0.</description>
      <operation>RCX := RCX - 1
if RCX != 0 AND ZF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Typically used with string comparison instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="loopnz" category="CONTROL_FLOW">
    <description>Loop if not zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Loop if Not Equal / Loop if Not Zero</summary>
      <description>Decrements the count register (ECX/RCX) and jumps to the target if the count is not zero and ZF=0.</description>
      <operation>RCX := RCX - 1
if RCX != 0 AND ZF = 0 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Typically used with string comparison instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="loopz" category="CONTROL_FLOW">
    <description>Loop if zero</description>
    <variants>
      <variant>
        <operand type="REL8" />
      </variant>
      <variant>
        <operand type="REL8" />
      </variant>
    </variants>
    <documentation>
      <summary>Loop if Equal / Loop if Zero</summary>
      <description>Decrements the count register (ECX/RCX) and jumps to the target if the count is not zero and ZF=1.</description>
      <operation>RCX := RCX - 1
if RCX != 0 AND ZF = 1 then
  RIP := RIP + offset</operation>
      <flags-affected>None</flags-affected>
      <notes>Typically used with string comparison instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="lsl" category="SYSTEM">
    <description>Load segment limit</description>
  </instruction>
  <instruction name="lss" category="DATA_MOVEMENT">
    <description>Load pointer using SS</description>
  </instruction>
  <instruction name="ltr" category="SYSTEM">
    <description>Load task register</description>
  </instruction>
  <instruction name="lzcnt" category="BIT_MANIPULATION">
    <description>Count leading zero bits</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Count the number of leading zero bits in the source operand</summary>
      <description>Counts the number of leading (most significant) zero bits in a source operand and returns the result into the destination. If the source operand is zero, LZCNT returns the operand size (16, 32, or 64). This differs from the BSR instruction, and on processors that don't support LZCNT, it executes as BSR.</description>
      <operation>DEST := Count of leading zero bits in SRC</operation>
      <flags-affected>ZF is set if output is zero; CF is set if input was zero; OF, SF, PF, AF are undefined</flags-affected>
      <notes>Requires CPUID LZCNT feature flag. In 64-bit mode, 64-bit operands require REX.W=1. On unsupporting processors, executes as BSR. Intrinsics: _lzcnt_u32() and _lzcnt_u64().</notes>
    </documentation>
  </instruction>
  <instruction name="maskmovdqu" category="SIMD">
    <description>Store selected bytes of double quadword</description>
  </instruction>
  <instruction name="maskmovq" category="SIMD">
    <description>Store selected bytes of quadword</description>
  </instruction>
  <instruction name="maxpd" category="SIMD">
    <description>Maximum of packed double-precision</description>
  </instruction>
  <instruction name="maxps" category="SIMD">
    <description>Maximum of packed single-precision</description>
  </instruction>
  <instruction name="maxsd" category="SIMD">
    <description>Maximum of scalar double-precision</description>
  </instruction>
  <instruction name="maxss" category="SIMD">
    <description>Maximum of scalar single-precision</description>
  </instruction>
  <instruction name="mfence" category="SYSTEM">
    <description>Memory fence</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Memory Fence</summary>
      <description>Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to the MFENCE instruction. Ensures that all previous memory operations are globally visible before any subsequent memory operation.</description>
      <operation>(serializing operation)</operation>
      <flags-affected>None</flags-affected>
      <notes>Strongest memory barrier. Ensures complete ordering of loads and stores.</notes>
    </documentation>
  </instruction>
  <instruction name="minpd" category="SIMD">
    <description>Minimum of packed double-precision</description>
  </instruction>
  <instruction name="minps" category="SIMD">
    <description>Minimum of packed single-precision</description>
  </instruction>
  <instruction name="minsd" category="SIMD">
    <description>Minimum of scalar double-precision</description>
  </instruction>
  <instruction name="minss" category="SIMD">
    <description>Minimum of scalar single-precision</description>
  </instruction>
  <instruction name="monitor" category="SYSTEM">
    <description>Set up a linear address range to monitor</description>
  </instruction>
  <instruction name="mov" category="DATA_MOVEMENT">
    <description>Move data</description>
    <documentation>
      <summary>Move</summary>
      <description>Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location. The destination operand can be a general-purpose register, segment register, or memory location. Both operands must be the same size.</description>
      <operation>DEST := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, the default operation size is 32 bits. Use REX.W prefix for 64-bit operations.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="REG8" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="REG16" />
        <operand type="SREG" />
      </variant>
      <variant>
        <operand type="SREG" />
        <operand type="R_M16" />
      </variant>
    </variants>
  </instruction>
  <instruction name="movabs" category="DATA_MOVEMENT">
    <description>Move absolute (64-bit immediate)</description>
  </instruction>
  <instruction name="movapd" category="SIMD">
    <description>Move aligned packed double-precision</description>
  </instruction>
  <instruction name="movaps" category="SIMD">
    <description>Move aligned packed single-precision</description>
  </instruction>
  <instruction name="movbe" category="DATA_MOVEMENT">
    <description>Move data after swapping bytes</description>
  </instruction>
  <instruction name="movd" category="SIMD">
    <description>Move doubleword (MMX/SSE)</description>
  </instruction>
  <instruction name="movddup" category="SIMD">
    <description>Move and duplicate double-precision</description>
  </instruction>
  <instruction name="movdq2q" category="SIMD">
    <description>Move quadword from XMM to MMX</description>
  </instruction>
  <instruction name="movdqa" category="SIMD">
    <description>Move aligned packed integers</description>
  </instruction>
  <instruction name="movdqu" category="SIMD">
    <description>Move unaligned packed integers</description>
  </instruction>
  <instruction name="movhlps" category="SIMD">
    <description>Move high to low packed single-precision</description>
  </instruction>
  <instruction name="movhpd" category="SIMD">
    <description>Move high packed double-precision</description>
  </instruction>
  <instruction name="movhps" category="SIMD">
    <description>Move high packed single-precision</description>
  </instruction>
  <instruction name="movlhps" category="SIMD">
    <description>Move low to high packed single-precision</description>
  </instruction>
  <instruction name="movlpd" category="SIMD">
    <description>Move low packed double-precision</description>
  </instruction>
  <instruction name="movlps" category="SIMD">
    <description>Move low packed single-precision</description>
  </instruction>
  <instruction name="movmskpd" category="SIMD">
    <description>Extract packed double-precision sign mask</description>
  </instruction>
  <instruction name="movmskps" category="SIMD">
    <description>Extract packed single-precision sign mask</description>
  </instruction>
  <instruction name="movntdq" category="SIMD">
    <description>Store packed integers using non-temporal hint</description>
  </instruction>
  <instruction name="movntdqa" category="SIMD">
    <description>Load double quadword non-temporal aligned hint</description>
  </instruction>
  <instruction name="movnti" category="SIMD">
    <description>Store doubleword using non-temporal hint</description>
  </instruction>
  <instruction name="movntpd" category="SIMD">
    <description>Store packed double-precision using non-temporal hint</description>
  </instruction>
  <instruction name="movntps" category="SIMD">
    <description>Store packed single-precision using non-temporal hint</description>
  </instruction>
  <instruction name="movq" category="SIMD">
    <description>Move quadword (MMX/SSE)</description>
  </instruction>
  <instruction name="movq2dq" category="SIMD">
    <description>Move quadword from MMX to XMM</description>
  </instruction>
  <instruction name="movs" category="STRING">
    <description>Move string</description>
    <variants>
      <variant>
        <operand type="MEM8" />
        <operand type="MEM8" />
      </variant>
      <variant>
        <operand type="MEM16" />
        <operand type="MEM16" />
      </variant>
      <variant>
        <operand type="MEM32" />
        <operand type="MEM32" />
      </variant>
      <variant>
        <operand type="MEM64" />
        <operand type="MEM64" />
      </variant>
    </variants>
    <documentation>
      <summary>Move data from string to string (memory to memory copy)</summary>
      <description>Moves a byte, word, doubleword, or quadword from the source memory location addressed by DS:(R|E)SI to the destination memory location addressed by ES:(R|E)DI. After the move, both (R|E)SI and (R|E)DI registers are automatically incremented or decremented based on the Direction Flag (DF). This instruction is fundamental for block memory copy operations.</description>
      <operation>[ES:(R|E)DI] := [DS:(R|E)SI]
(R|E)SI := (R|E)SI +/- operand_size
(R|E)DI := (R|E)DI +/- operand_size</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block moves. Source is DS:(R|E)SI, destination is ES:(R|E)DI. ES segment cannot be overridden.</notes>
    </documentation>
  </instruction>
  <instruction name="movsb" category="STRING">
    <description>Move byte string</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Move String</summary>
      <description>Moves data from the memory location pointed to by RSI to the memory location pointed to by RDI. Then increments or decrements (depending on DF) both pointers.</description>
      <operation>[RDI] := [RSI]
RDI := RDI +/- size
RSI := RSI +/- size</operation>
      <flags-affected>None</flags-affected>
      <notes>Often used with REP prefix for block moves. Direction controlled by DF flag.</notes>
    </documentation>
  </instruction>
  <instruction name="movsd" category="SIMD">
    <description>Move scalar double-precision</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Move string doubleword from DS:(R|E)SI to ES:(R|E)DI</summary>
      <description>Moves a doubleword (32-bit) from the source memory location addressed by DS:(R|E)SI to the destination memory location addressed by ES:(R|E)DI. After the move, both (R|E)SI and (R|E)DI registers are automatically incremented or decremented by 4 based on the Direction Flag (DF). This is the no-operands form of MOVS for doubleword-sized operations.</description>
      <operation>[ES:(R|E)DI] := [DS:(R|E)SI]
(R|E)SI := (R|E)SI +/- 4
(R|E)DI := (R|E)DI +/- 4</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block moves. ES segment cannot be overridden. Note: This mnemonic may conflict with SSE MOVSD in some assemblers.</notes>
    </documentation>
  </instruction>
  <instruction name="movshdup" category="SIMD">
    <description>Move and duplicate high single-precision</description>
  </instruction>
  <instruction name="movsldup" category="SIMD">
    <description>Move and duplicate low single-precision</description>
  </instruction>
  <instruction name="movsq" category="STRING">
    <description>Move quadword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Move string quadword from DS:RSI to ES:RDI</summary>
      <description>Moves a quadword (64-bit) from the source memory location addressed by RSI to the destination memory location addressed by RDI. After the move, both RSI and RDI registers are automatically incremented or decremented by 8 based on the Direction Flag (DF). This is the no-operands form of MOVS for quadword-sized operations and is only available in 64-bit mode.</description>
      <operation>[ES:RDI] := [DS:RSI]
RSI := RSI +/- 8
RDI := RDI +/- 8</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block moves. Only available in 64-bit mode. ES segment cannot be overridden.</notes>
    </documentation>
  </instruction>
  <instruction name="movss" category="SIMD">
    <description>Move scalar single-precision</description>
  </instruction>
  <instruction name="movsw" category="STRING">
    <description>Move word string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Move string word from DS:(R|E)SI to ES:(R|E)DI</summary>
      <description>Moves a word (16-bit) from the source memory location addressed by DS:(R|E)SI to the destination memory location addressed by ES:(R|E)DI. After the move, both (R|E)SI and (R|E)DI registers are automatically incremented or decremented by 2 based on the Direction Flag (DF). This is the no-operands form of MOVS for word-sized operations.</description>
      <operation>[ES:(R|E)DI] := [DS:(R|E)SI]
(R|E)SI := (R|E)SI +/- 2
(R|E)DI := (R|E)DI +/- 2</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block moves. ES segment cannot be overridden.</notes>
    </documentation>
  </instruction>
  <instruction name="movsx" category="DATA_MOVEMENT">
    <description>Move with sign-extension</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M16" />
      </variant>
    </variants>
    <documentation>
      <summary>Move with Sign-Extend</summary>
      <description>Copies the source operand to the destination operand and sign extends the value. The source operand must be smaller than the destination operand.</description>
      <operation>DEST := SignExtend(SRC)</operation>
      <flags-affected>None</flags-affected>
      <notes>Useful for converting signed values to larger sizes.</notes>
    </documentation>
  </instruction>
  <instruction name="movsxd" category="DATA_MOVEMENT">
    <description>Move with sign-extension doubleword</description>
    <variants>
      <variant>
        <operand type="REG64" />
        <operand type="R_M32" />
      </variant>
    </variants>
    <documentation>
      <summary>Move with Sign-Extend Doubleword</summary>
      <description>Copies a doubleword to a quadword with sign-extension. Only available in 64-bit mode.</description>
      <operation>DEST := SignExtend(SRC)</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, this is the only way to sign-extend a 32-bit value to 64 bits.</notes>
    </documentation>
  </instruction>
  <instruction name="movupd" category="SIMD">
    <description>Move unaligned packed double-precision</description>
  </instruction>
  <instruction name="movups" category="SIMD">
    <description>Move unaligned packed single-precision</description>
  </instruction>
  <instruction name="movzx" category="DATA_MOVEMENT">
    <description>Move with zero-extension</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M16" />
      </variant>
    </variants>
    <documentation>
      <summary>Move with Zero-Extend</summary>
      <description>Copies the source operand to the destination operand and zero extends the value. The source operand must be smaller than the destination operand.</description>
      <operation>DEST := ZeroExtend(SRC)</operation>
      <flags-affected>None</flags-affected>
      <notes>Useful for converting unsigned values to larger sizes.</notes>
    </documentation>
  </instruction>
  <instruction name="mpsadbw" category="SIMD">
    <description>Multiple packed sums of absolute difference</description>
  </instruction>
  <instruction name="mul" category="ARITHMETIC">
    <description>Unsigned multiply</description>
    <documentation>
      <summary>Unsigned Multiply</summary>
      <description>Performs an unsigned multiplication of the source operand and the accumulator. For byte operands, the result is stored in AX. For word operands, the result is stored in DX:AX. For doubleword operands, the result is stored in EDX:EAX. For quadword operands, the result is stored in RDX:RAX.</description>
      <operation>if operand size is 8:
  AX := AL * SRC
else if operand size is 16:
  DX:AX := AX * SRC
else if operand size is 32:
  EDX:EAX := EAX * SRC
else if operand size is 64:
  RDX:RAX := RAX * SRC</operation>
      <flags-affected>OF, CF (SF, ZF, AF, PF undefined)</flags-affected>
      <notes>OF and CF flags are cleared if the upper half of the result is 0; otherwise, they are set.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="mulpd" category="SIMD">
    <description>Multiply packed double-precision</description>
  </instruction>
  <instruction name="mulps" category="SIMD">
    <description>Multiply packed single-precision</description>
  </instruction>
  <instruction name="mulsd" category="SIMD">
    <description>Multiply scalar double-precision</description>
  </instruction>
  <instruction name="mulss" category="SIMD">
    <description>Multiply scalar single-precision</description>
  </instruction>
  <instruction name="mulx" category="BIT_MANIPULATION">
    <description>Unsigned multiply without affecting flags (BMI2)</description>
  </instruction>
  <instruction name="mwait" category="SYSTEM">
    <description>Wait for write-back store</description>
  </instruction>
  <instruction name="neg" category="ARITHMETIC">
    <description>Negate</description>
    <documentation>
      <summary>Two's Complement Negation</summary>
      <description>Replaces the value of the operand with its two's complement. The operand can be a register or memory location.</description>
      <operation>DEST := 0 - DEST</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>CF is set to 1 unless the operand is 0. OF is set if the operand is the maximum negative value.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
      </variant>
    </variants>
  </instruction>
  <instruction name="nop" category="SYSTEM">
    <description>No operation</description>
    <variants>
      <variant />
      <variant>
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>No Operation</summary>
      <description>Performs no operation. This instruction is a one-byte instruction that takes up space but affects none of the machine context except the RIP register.</description>
      <operation>(no operation)</operation>
      <flags-affected>None</flags-affected>
      <notes>The multi-byte forms are used for instruction alignment.</notes>
    </documentation>
  </instruction>
  <instruction name="not" category="LOGIC">
    <description>Logical NOT</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>One's Complement Negation</summary>
      <description>Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand.</description>
      <operation>DEST := NOT DEST</operation>
      <flags-affected>None</flags-affected>
      <notes>No flags are affected.</notes>
    </documentation>
  </instruction>
  <instruction name="or" category="LOGIC">
    <description>Logical OR</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="REG8" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM32" />
      </variant>
    </variants>
    <documentation>
      <summary>Logical OR</summary>
      <description>Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location.</description>
      <operation>DEST := DEST OR SRC</operation>
      <flags-affected>OF=0, CF=0, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>OF and CF flags are cleared. The SF, ZF, and PF flags are set according to the result.</notes>
    </documentation>
  </instruction>
  <instruction name="orpd" category="SIMD">
    <description>Bitwise OR of packed double-precision</description>
  </instruction>
  <instruction name="orps" category="SIMD">
    <description>Bitwise OR of packed single-precision</description>
  </instruction>
  <instruction name="out" category="IO">
    <description>Output to port</description>
    <variants>
      <variant>
        <operand type="IMM8" />
        <operand type="AL" />
      </variant>
      <variant>
        <operand type="IMM8" />
        <operand type="AX" />
      </variant>
      <variant>
        <operand type="IMM8" />
        <operand type="EAX" />
      </variant>
      <variant>
        <operand type="DX" />
        <operand type="AL" />
      </variant>
      <variant>
        <operand type="DX" />
        <operand type="AX" />
      </variant>
      <variant>
        <operand type="DX" />
        <operand type="EAX" />
      </variant>
    </variants>
    <documentation>
      <summary>Output to Port</summary>
      <description>Writes data from the accumulator register (AL, AX, or EAX) to the specified I/O port. This instruction is privileged if CPL &gt; IOPL or if I/O permission bitmap denies access.</description>
      <operation>IOPort[port] := AL/AX/EAX</operation>
      <flags-affected>None</flags-affected>
      <notes>Port number can be immediate (0-255) or in DX (0-65535). May be privileged depending on IOPL and I/O permission bitmap.</notes>
    </documentation>
  </instruction>
  <instruction name="outs" category="IO">
    <description>Output string to port</description>
  </instruction>
  <instruction name="outsb" category="IO">
    <description>Output byte string to port</description>
  </instruction>
  <instruction name="outsd" category="IO">
    <description>Output doubleword string to port</description>
  </instruction>
  <instruction name="outsw" category="IO">
    <description>Output word string to port</description>
  </instruction>
  <instruction name="pabsb" category="SIMD">
    <description>Packed absolute value of bytes</description>
  </instruction>
  <instruction name="pabsd" category="SIMD">
    <description>Packed absolute value of doublewords</description>
  </instruction>
  <instruction name="pabsw" category="SIMD">
    <description>Packed absolute value of words</description>
  </instruction>
  <instruction name="packssdw" category="SIMD">
    <description>Pack signed doublewords into words with saturation</description>
  </instruction>
  <instruction name="packsswb" category="SIMD">
    <description>Pack signed words into bytes with saturation</description>
  </instruction>
  <instruction name="packusdw" category="SIMD">
    <description>Pack doublewords into words with unsigned saturation</description>
  </instruction>
  <instruction name="packuswb" category="SIMD">
    <description>Pack unsigned words into bytes with saturation</description>
  </instruction>
  <instruction name="paddb" category="SIMD">
    <description>Add packed bytes</description>
  </instruction>
  <instruction name="paddd" category="SIMD">
    <description>Add packed doublewords</description>
  </instruction>
  <instruction name="paddq" category="SIMD">
    <description>Add packed quadwords</description>
  </instruction>
  <instruction name="paddsb" category="SIMD">
    <description>Add packed signed bytes with saturation</description>
  </instruction>
  <instruction name="paddsw" category="SIMD">
    <description>Add packed signed words with saturation</description>
  </instruction>
  <instruction name="paddusb" category="SIMD">
    <description>Add packed unsigned bytes with saturation</description>
  </instruction>
  <instruction name="paddusw" category="SIMD">
    <description>Add packed unsigned words with saturation</description>
  </instruction>
  <instruction name="paddw" category="SIMD">
    <description>Add packed words</description>
  </instruction>
  <instruction name="palignr" category="SIMD">
    <description>Packed align right</description>
  </instruction>
  <instruction name="pand" category="SIMD">
    <description>Packed AND</description>
  </instruction>
  <instruction name="pandn" category="SIMD">
    <description>Packed AND NOT</description>
  </instruction>
  <instruction name="pause" category="SYSTEM">
    <description>Spin loop hint</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Spin Loop Hint</summary>
      <description>Provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid memory order violations that can cause performance degradation. Also improves power consumption and reduces resource contention in hyper-threaded processors.</description>
      <operation>(implementation-specific optimization)</operation>
      <flags-affected>None</flags-affected>
      <notes>Commonly used in spin-lock loops. Improves performance and power efficiency on modern processors.</notes>
    </documentation>
  </instruction>
  <instruction name="pavgb" category="SIMD">
    <description>Average packed bytes</description>
  </instruction>
  <instruction name="pavgw" category="SIMD">
    <description>Average packed words</description>
  </instruction>
  <instruction name="pblendvb" category="SIMD">
    <description>Variable blend packed bytes</description>
  </instruction>
  <instruction name="pblendw" category="SIMD">
    <description>Blend packed words</description>
  </instruction>
  <instruction name="pclmulqdq" category="CRYPTO">
    <description>Carry-less multiplication quadword</description>
  </instruction>
  <instruction name="pcmpeqb" category="SIMD">
    <description>Compare packed bytes for equality</description>
  </instruction>
  <instruction name="pcmpeqd" category="SIMD">
    <description>Compare packed doublewords for equality</description>
  </instruction>
  <instruction name="pcmpeqq" category="SIMD">
    <description>Compare packed quadwords for equality</description>
  </instruction>
  <instruction name="pcmpeqw" category="SIMD">
    <description>Compare packed words for equality</description>
  </instruction>
  <instruction name="pcmpestri" category="SIMD">
    <description>Packed compare explicit length strings, return index</description>
  </instruction>
  <instruction name="pcmpestrm" category="SIMD">
    <description>Packed compare explicit length strings, return mask</description>
  </instruction>
  <instruction name="pcmpgtb" category="SIMD">
    <description>Compare packed signed bytes for greater than</description>
  </instruction>
  <instruction name="pcmpgtd" category="SIMD">
    <description>Compare packed signed doublewords for greater than</description>
  </instruction>
  <instruction name="pcmpgtq" category="SIMD">
    <description>Compare packed signed qwords for greater than</description>
  </instruction>
  <instruction name="pcmpgtw" category="SIMD">
    <description>Compare packed signed words for greater than</description>
  </instruction>
  <instruction name="pcmpistri" category="SIMD">
    <description>Packed compare implicit length strings, return index</description>
  </instruction>
  <instruction name="pcmpistrm" category="SIMD">
    <description>Packed compare implicit length strings, return mask</description>
  </instruction>
  <instruction name="pdep" category="BIT_MANIPULATION">
    <description>Parallel bits deposit (BMI2)</description>
  </instruction>
  <instruction name="pext" category="BIT_MANIPULATION">
    <description>Parallel bits extract (BMI2)</description>
  </instruction>
  <instruction name="pextrb" category="SIMD">
    <description>Extract byte</description>
  </instruction>
  <instruction name="pextrd" category="SIMD">
    <description>Extract doubleword</description>
  </instruction>
  <instruction name="pextrq" category="SIMD">
    <description>Extract quadword</description>
  </instruction>
  <instruction name="pextrw" category="SIMD">
    <description>Extract word</description>
  </instruction>
  <instruction name="phaddd" category="SIMD">
    <description>Packed horizontal add doublewords</description>
  </instruction>
  <instruction name="phaddsw" category="SIMD">
    <description>Packed horizontal add signed words with saturation</description>
  </instruction>
  <instruction name="phaddw" category="SIMD">
    <description>Packed horizontal add words</description>
  </instruction>
  <instruction name="phminposuw" category="SIMD">
    <description>Packed horizontal word minimum</description>
  </instruction>
  <instruction name="phsubd" category="SIMD">
    <description>Packed horizontal subtract doublewords</description>
  </instruction>
  <instruction name="phsubsw" category="SIMD">
    <description>Packed horizontal subtract signed words with saturation</description>
  </instruction>
  <instruction name="phsubw" category="SIMD">
    <description>Packed horizontal subtract words</description>
  </instruction>
  <instruction name="pinsrb" category="SIMD">
    <description>Insert byte</description>
  </instruction>
  <instruction name="pinsrd" category="SIMD">
    <description>Insert doubleword</description>
  </instruction>
  <instruction name="pinsrq" category="SIMD">
    <description>Insert quadword</description>
  </instruction>
  <instruction name="pinsrw" category="SIMD">
    <description>Insert word</description>
  </instruction>
  <instruction name="pmaddubsw" category="SIMD">
    <description>Multiply and add packed unsigned/signed bytes</description>
  </instruction>
  <instruction name="pmaddwd" category="SIMD">
    <description>Multiply and add packed words</description>
  </instruction>
  <instruction name="pmaxsb" category="SIMD">
    <description>Maximum of packed signed bytes</description>
  </instruction>
  <instruction name="pmaxsd" category="SIMD">
    <description>Maximum of packed signed doublewords</description>
  </instruction>
  <instruction name="pmaxsw" category="SIMD">
    <description>Maximum of packed signed words</description>
  </instruction>
  <instruction name="pmaxub" category="SIMD">
    <description>Maximum of packed unsigned bytes</description>
  </instruction>
  <instruction name="pmaxud" category="SIMD">
    <description>Maximum of packed unsigned doublewords</description>
  </instruction>
  <instruction name="pmaxuw" category="SIMD">
    <description>Maximum of packed unsigned words</description>
  </instruction>
  <instruction name="pminsb" category="SIMD">
    <description>Minimum of packed signed bytes</description>
  </instruction>
  <instruction name="pminsd" category="SIMD">
    <description>Minimum of packed signed doublewords</description>
  </instruction>
  <instruction name="pminsw" category="SIMD">
    <description>Minimum of packed signed words</description>
  </instruction>
  <instruction name="pminub" category="SIMD">
    <description>Minimum of packed unsigned bytes</description>
  </instruction>
  <instruction name="pminud" category="SIMD">
    <description>Minimum of packed unsigned doublewords</description>
  </instruction>
  <instruction name="pminuw" category="SIMD">
    <description>Minimum of packed unsigned words</description>
  </instruction>
  <instruction name="pmovmskb" category="SIMD">
    <description>Move byte mask</description>
  </instruction>
  <instruction name="pmovsxbd" category="SIMD">
    <description>Sign extend packed bytes to doublewords</description>
  </instruction>
  <instruction name="pmovsxbq" category="SIMD">
    <description>Sign extend packed bytes to quadwords</description>
  </instruction>
  <instruction name="pmovsxbw" category="SIMD">
    <description>Sign extend packed bytes to words</description>
  </instruction>
  <instruction name="pmovsxdq" category="SIMD">
    <description>Sign extend packed doublewords to quadwords</description>
  </instruction>
  <instruction name="pmovsxwd" category="SIMD">
    <description>Sign extend packed words to doublewords</description>
  </instruction>
  <instruction name="pmovsxwq" category="SIMD">
    <description>Sign extend packed words to quadwords</description>
  </instruction>
  <instruction name="pmovzxbd" category="SIMD">
    <description>Zero extend packed bytes to doublewords</description>
  </instruction>
  <instruction name="pmovzxbq" category="SIMD">
    <description>Zero extend packed bytes to quadwords</description>
  </instruction>
  <instruction name="pmovzxbw" category="SIMD">
    <description>Zero extend packed bytes to words</description>
  </instruction>
  <instruction name="pmovzxdq" category="SIMD">
    <description>Zero extend packed doublewords to quadwords</description>
  </instruction>
  <instruction name="pmovzxwd" category="SIMD">
    <description>Zero extend packed words to doublewords</description>
  </instruction>
  <instruction name="pmovzxwq" category="SIMD">
    <description>Zero extend packed words to quadwords</description>
  </instruction>
  <instruction name="pmuldq" category="SIMD">
    <description>Multiply packed signed doubleword integers</description>
  </instruction>
  <instruction name="pmulhrsw" category="SIMD">
    <description>Packed multiply high with round and scale</description>
  </instruction>
  <instruction name="pmulhuw" category="SIMD">
    <description>Multiply packed unsigned words and store high result</description>
  </instruction>
  <instruction name="pmulhw" category="SIMD">
    <description>Multiply packed signed words and store high result</description>
  </instruction>
  <instruction name="pmulld" category="SIMD">
    <description>Multiply packed signed doubleword integers and store low result</description>
  </instruction>
  <instruction name="pmullw" category="SIMD">
    <description>Multiply packed signed words and store low result</description>
  </instruction>
  <instruction name="pmuludq" category="SIMD">
    <description>Multiply packed unsigned doubleword integers</description>
  </instruction>
  <instruction name="pop" category="DATA_MOVEMENT">
    <description>Pop from stack</description>
    <documentation>
      <summary>Pop a Value from the Stack</summary>
      <description>Loads the value from the top of the stack to the destination operand and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.</description>
      <operation>DEST := [RSP]
RSP := RSP + 8</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, the default pop size is 64 bits (8 bytes).</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="R_M64" />
      </variant>
      <variant>
        <operand type="SREG" />
      </variant>
    </variants>
  </instruction>
  <instruction name="popa" category="DATA_MOVEMENT">
    <description>Pop all general-purpose registers (16/32-bit mode)</description>
  </instruction>
  <instruction name="popad" category="DATA_MOVEMENT">
    <description>Pop all doubleword registers (32-bit mode)</description>
  </instruction>
  <instruction name="popcnt" category="BIT_MANIPULATION">
    <description>Return number of bits set to 1</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Count the number of bits set to 1 in the source operand</summary>
      <description>This instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the first operand (destination). It provides an efficient way to perform population count operations on 16, 32, or 64-bit operands.</description>
      <operation>DEST := Count of set bits in SRC</operation>
      <flags-affected>OF, SF, AF, CF, PF are cleared; ZF is set if source is 0</flags-affected>
      <notes>Requires CPUID.01H:ECX.POPCNT [Bit 23] = 1. Not supported with LOCK prefix. Compiler intrinsics: _mm_popcnt_u32() and _mm_popcnt_u64().</notes>
    </documentation>
  </instruction>
  <instruction name="popf" category="SYSTEM">
    <description>Pop flags</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Pop Stack into FLAGS/EFLAGS/RFLAGS Register</summary>
      <description>Loads the flags register from the top of the stack and then increments the stack pointer.</description>
      <operation>RFLAGS := [RSP]
RSP := RSP + 8</operation>
      <flags-affected>All flags (depending on privilege level)</flags-affected>
      <notes>Some flag bits cannot be modified depending on current privilege level.</notes>
    </documentation>
  </instruction>
  <instruction name="popfd" category="SYSTEM">
    <description>Pop EFLAGS</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Pop Stack into FLAGS/EFLAGS/RFLAGS Register</summary>
      <description>Loads the flags register from the top of the stack and then increments the stack pointer.</description>
      <operation>RFLAGS := [RSP]
RSP := RSP + 8</operation>
      <flags-affected>All flags (depending on privilege level)</flags-affected>
      <notes>Some flag bits cannot be modified depending on current privilege level.</notes>
    </documentation>
  </instruction>
  <instruction name="popfq" category="SYSTEM">
    <description>Pop RFLAGS</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Pop Stack into FLAGS/EFLAGS/RFLAGS Register</summary>
      <description>Loads the flags register from the top of the stack and then increments the stack pointer.</description>
      <operation>RFLAGS := [RSP]
RSP := RSP + 8</operation>
      <flags-affected>All flags (depending on privilege level)</flags-affected>
      <notes>Some flag bits cannot be modified depending on current privilege level.</notes>
    </documentation>
  </instruction>
  <instruction name="por" category="SIMD">
    <description>Packed OR</description>
  </instruction>
  <instruction name="prefetch" category="SYSTEM">
    <description>Prefetch data into caches</description>
  </instruction>
  <instruction name="prefetchnta" category="SYSTEM">
    <description>Prefetch non-temporal data</description>
  </instruction>
  <instruction name="prefetcht0" category="SYSTEM">
    <description>Prefetch temporal data (L1 cache)</description>
  </instruction>
  <instruction name="prefetcht1" category="SYSTEM">
    <description>Prefetch temporal data (L2 cache)</description>
  </instruction>
  <instruction name="prefetcht2" category="SYSTEM">
    <description>Prefetch temporal data (L3 cache)</description>
  </instruction>
  <instruction name="prefetchw" category="SYSTEM">
    <description>Prefetch data with intent to write</description>
  </instruction>
  <instruction name="prefetchwt1" category="SYSTEM">
    <description>Prefetch vector data with intent to write (L2 cache)</description>
  </instruction>
  <instruction name="psadbw" category="SIMD">
    <description>Sum of absolute differences of packed unsigned bytes</description>
  </instruction>
  <instruction name="pshufb" category="SIMD">
    <description>Packed shuffle bytes</description>
  </instruction>
  <instruction name="pshufd" category="SIMD">
    <description>Shuffle packed doublewords</description>
  </instruction>
  <instruction name="pshufhw" category="SIMD">
    <description>Shuffle packed high words</description>
  </instruction>
  <instruction name="pshuflw" category="SIMD">
    <description>Shuffle packed low words</description>
  </instruction>
  <instruction name="psignb" category="SIMD">
    <description>Packed sign bytes</description>
  </instruction>
  <instruction name="psignd" category="SIMD">
    <description>Packed sign doublewords</description>
  </instruction>
  <instruction name="psignw" category="SIMD">
    <description>Packed sign words</description>
  </instruction>
  <instruction name="pslld" category="SIMD">
    <description>Shift packed doublewords left logical</description>
  </instruction>
  <instruction name="pslldq" category="SIMD">
    <description>Shift double quadword left logical</description>
  </instruction>
  <instruction name="psllq" category="SIMD">
    <description>Shift packed quadwords left logical</description>
  </instruction>
  <instruction name="psllw" category="SIMD">
    <description>Shift packed words left logical</description>
  </instruction>
  <instruction name="psrad" category="SIMD">
    <description>Shift packed doublewords right arithmetic</description>
  </instruction>
  <instruction name="psraw" category="SIMD">
    <description>Shift packed words right arithmetic</description>
  </instruction>
  <instruction name="psrld" category="SIMD">
    <description>Shift packed doublewords right logical</description>
  </instruction>
  <instruction name="psrldq" category="SIMD">
    <description>Shift double quadword right logical</description>
  </instruction>
  <instruction name="psrlq" category="SIMD">
    <description>Shift packed quadwords right logical</description>
  </instruction>
  <instruction name="psrlw" category="SIMD">
    <description>Shift packed words right logical</description>
  </instruction>
  <instruction name="psubb" category="SIMD">
    <description>Subtract packed bytes</description>
  </instruction>
  <instruction name="psubd" category="SIMD">
    <description>Subtract packed doublewords</description>
  </instruction>
  <instruction name="psubq" category="SIMD">
    <description>Subtract packed quadwords</description>
  </instruction>
  <instruction name="psubsb" category="SIMD">
    <description>Subtract packed signed bytes with saturation</description>
  </instruction>
  <instruction name="psubsw" category="SIMD">
    <description>Subtract packed signed words with saturation</description>
  </instruction>
  <instruction name="psubusb" category="SIMD">
    <description>Subtract packed unsigned bytes with saturation</description>
  </instruction>
  <instruction name="psubusw" category="SIMD">
    <description>Subtract packed unsigned words with saturation</description>
  </instruction>
  <instruction name="psubw" category="SIMD">
    <description>Subtract packed words</description>
  </instruction>
  <instruction name="ptest" category="SIMD">
    <description>Logical compare</description>
  </instruction>
  <instruction name="punpckhbw" category="SIMD">
    <description>Unpack high bytes</description>
  </instruction>
  <instruction name="punpckhdq" category="SIMD">
    <description>Unpack high doublewords</description>
  </instruction>
  <instruction name="punpckhqdq" category="SIMD">
    <description>Unpack high quadwords</description>
  </instruction>
  <instruction name="punpckhwd" category="SIMD">
    <description>Unpack high words</description>
  </instruction>
  <instruction name="punpcklbw" category="SIMD">
    <description>Unpack low bytes</description>
  </instruction>
  <instruction name="punpckldq" category="SIMD">
    <description>Unpack low doublewords</description>
  </instruction>
  <instruction name="punpcklqdq" category="SIMD">
    <description>Unpack low quadwords</description>
  </instruction>
  <instruction name="punpcklwd" category="SIMD">
    <description>Unpack low words</description>
  </instruction>
  <instruction name="push" category="DATA_MOVEMENT">
    <description>Push onto stack</description>
    <documentation>
      <summary>Push Word, Doubleword, or Quadword onto the Stack</summary>
      <description>Decrements the stack pointer and then stores the source operand on the top of the stack. The operand can be a register, memory location, or immediate value.</description>
      <operation>RSP := RSP - 8
[RSP] := SRC</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, the default push size is 64 bits (8 bytes).</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="R_M64" />
      </variant>
      <variant>
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="IMM16" />
      </variant>
      <variant>
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="SREG" />
      </variant>
    </variants>
  </instruction>
  <instruction name="pusha" category="DATA_MOVEMENT">
    <description>Push all general-purpose registers (16/32-bit mode)</description>
  </instruction>
  <instruction name="pushad" category="DATA_MOVEMENT">
    <description>Push all doubleword registers (32-bit mode)</description>
  </instruction>
  <instruction name="pushf" category="SYSTEM">
    <description>Push flags</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Push FLAGS/EFLAGS/RFLAGS Register onto the Stack</summary>
      <description>Decrements the stack pointer and then stores the flags register on the top of the stack.</description>
      <operation>RSP := RSP - 8
[RSP] := RFLAGS</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, PUSHFQ pushes 64-bit RFLAGS (though upper 32 bits are reserved).</notes>
    </documentation>
  </instruction>
  <instruction name="pushfd" category="SYSTEM">
    <description>Push EFLAGS</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Push FLAGS/EFLAGS/RFLAGS Register onto the Stack</summary>
      <description>Decrements the stack pointer and then stores the flags register on the top of the stack.</description>
      <operation>RSP := RSP - 8
[RSP] := RFLAGS</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, PUSHFQ pushes 64-bit RFLAGS (though upper 32 bits are reserved).</notes>
    </documentation>
  </instruction>
  <instruction name="pushfq" category="SYSTEM">
    <description>Push RFLAGS</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Push FLAGS/EFLAGS/RFLAGS Register onto the Stack</summary>
      <description>Decrements the stack pointer and then stores the flags register on the top of the stack.</description>
      <operation>RSP := RSP - 8
[RSP] := RFLAGS</operation>
      <flags-affected>None</flags-affected>
      <notes>In 64-bit mode, PUSHFQ pushes 64-bit RFLAGS (though upper 32 bits are reserved).</notes>
    </documentation>
  </instruction>
  <instruction name="pxor" category="SIMD">
    <description>Packed XOR</description>
  </instruction>
  <instruction name="rcl" category="BIT_MANIPULATION">
    <description>Rotate through carry left</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Rotate Through Carry Left</summary>
      <description>Rotates the bits in the first operand to the left by the count specified in the second operand. The carry flag (CF) is included in the rotation.</description>
      <operation>DEST := (DEST &lt;&lt; COUNT) with CF included in rotation</operation>
      <flags-affected>CF, OF (SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Useful for multi-precision shifts. CF becomes part of the rotation.</notes>
    </documentation>
  </instruction>
  <instruction name="rcpps" category="SIMD">
    <description>Reciprocal of packed single-precision</description>
  </instruction>
  <instruction name="rcpss" category="SIMD">
    <description>Reciprocal of scalar single-precision</description>
  </instruction>
  <instruction name="rcr" category="BIT_MANIPULATION">
    <description>Rotate through carry right</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Rotate Through Carry Right</summary>
      <description>Rotates the bits in the first operand to the right by the count specified in the second operand. The carry flag (CF) is included in the rotation.</description>
      <operation>DEST := (DEST &gt;&gt; COUNT) with CF included in rotation</operation>
      <flags-affected>CF, OF (SF, ZF, AF, PF undefined)</flags-affected>
      <notes>Useful for multi-precision shifts. CF becomes part of the rotation.</notes>
    </documentation>
  </instruction>
  <instruction name="rdmsr" category="SYSTEM">
    <description>Read model specific register</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Read Model-Specific Register</summary>
      <description>Reads the 64-bit Model-Specific Register (MSR) specified in the ECX register into registers EDX:EAX. This instruction is privileged (CPL=0) and can only be executed in kernel mode.</description>
      <operation>EDX:EAX := MSR[ECX]</operation>
      <flags-affected>None</flags-affected>
      <notes>Privileged instruction. Input: ECX contains the MSR address. Output: EDX contains high 32 bits, EAX contains low 32 bits.</notes>
    </documentation>
  </instruction>
  <instruction name="rdpmc" category="SYSTEM">
    <description>Read performance monitoring counter</description>
  </instruction>
  <instruction name="rdrand" category="SYSTEM">
    <description>Read random number</description>
  </instruction>
  <instruction name="rdseed" category="SYSTEM">
    <description>Read random seed</description>
  </instruction>
  <instruction name="rdtsc" category="SYSTEM">
    <description>Read time-stamp counter</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Read Time-Stamp Counter</summary>
      <description>Reads the 64-bit time-stamp counter into EDX:EAX. The time-stamp counter increments with every clock cycle.</description>
      <operation>EDX:EAX := TimeStampCounter</operation>
      <flags-affected>None</flags-affected>
      <notes>EDX contains the high-order 32 bits; EAX contains the low-order 32 bits. Used for performance measurement.</notes>
    </documentation>
  </instruction>
  <instruction name="rdtscp" category="SYSTEM">
    <description>Read time-stamp counter and processor ID</description>
  </instruction>
  <instruction name="rep" category="STRING">
    <description>Repeat string operation</description>
    <variants>
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Repeat String Operation</summary>
      <description>Repeats a string instruction while RCX is not zero. Decrements RCX for each iteration.</description>
      <operation>while RCX != 0 do
  perform string operation
  RCX := RCX - 1</operation>
      <flags-affected>None</flags-affected>
      <notes>Used with MOVS, STOS, LODS for efficient block operations.</notes>
    </documentation>
  </instruction>
  <instruction name="repe" category="STRING">
    <description>Repeat while equal</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Repeat String Operation While Equal/Zero</summary>
      <description>Repeats a string instruction while RCX is not zero and ZF=1. Decrements RCX for each iteration.</description>
      <operation>while RCX != 0 AND ZF = 1 do
  perform string operation
  RCX := RCX - 1</operation>
      <flags-affected>None</flags-affected>
      <notes>Used with CMPS and SCAS. Stops when strings differ or count expires.</notes>
    </documentation>
  </instruction>
  <instruction name="repne" category="STRING">
    <description>Repeat while not equal</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Repeat String Operation While Not Equal/Not Zero</summary>
      <description>Repeats a string instruction while RCX is not zero and ZF=0. Decrements RCX for each iteration.</description>
      <operation>while RCX != 0 AND ZF = 0 do
  perform string operation
  RCX := RCX - 1</operation>
      <flags-affected>None</flags-affected>
      <notes>Used with CMPS and SCAS. Stops when strings match or count expires.</notes>
    </documentation>
  </instruction>
  <instruction name="repnz" category="STRING">
    <description>Repeat while not zero</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Repeat string operation while Zero Flag is clear (alias for REPNE)</summary>
      <description>A prefix that causes the associated string instruction (CMPS or SCAS) to repeat while the count register (R)CX is not zero and the Zero Flag (ZF) is clear. The count register is decremented after each iteration. REPNZ is functionally identical to REPNE and is typically used with comparison instructions when searching for matching elements.</description>
      <operation>WHILE (R)CX ≠ 0 AND ZF = 0
  Execute string instruction
  (R)CX := (R)CX - 1</operation>
      <flags-affected>None directly (CMPS/SCAS instructions set flags)</flags-affected>
      <notes>Used only with CMPS and SCAS instructions. Terminates when (R)CX=0 or ZF=1. In 64-bit mode, uses RCX as count register.</notes>
    </documentation>
  </instruction>
  <instruction name="repz" category="STRING">
    <description>Repeat while zero</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Repeat string operation while Zero Flag is set (alias for REPE)</summary>
      <description>A prefix that causes the associated string instruction (CMPS or SCAS) to repeat while the count register (R)CX is not zero and the Zero Flag (ZF) is set. The count register is decremented after each iteration. REPZ is functionally identical to REPE and is typically used with comparison instructions when searching for non-matching elements.</description>
      <operation>WHILE (R)CX ≠ 0 AND ZF = 1
  Execute string instruction
  (R)CX := (R)CX - 1</operation>
      <flags-affected>None directly (CMPS/SCAS instructions set flags)</flags-affected>
      <notes>Used only with CMPS and SCAS instructions. Terminates when (R)CX=0 or ZF=0. In 64-bit mode, uses RCX as count register.</notes>
    </documentation>
  </instruction>
  <instruction name="ret" category="CONTROL_FLOW">
    <description>Return from procedure</description>
    <variants>
      <variant />
      <variant>
        <operand type="IMM16" />
      </variant>
    </variants>
    <documentation>
      <summary>Return from Procedure</summary>
      <description>Transfers program control to a return address located on the top of the stack. The return address is popped from the stack.</description>
      <operation>RIP := pop()
if imm16 present then
  RSP := RSP + imm16</operation>
      <flags-affected>None</flags-affected>
      <notes>The optional immediate operand specifies the number of bytes to release from the stack after the return.</notes>
    </documentation>
  </instruction>
  <instruction name="retf" category="CONTROL_FLOW">
    <description>Far return from procedure</description>
    <variants>
      <variant />
      <variant>
        <operand type="IMM16" />
      </variant>
    </variants>
    <documentation>
      <summary>Return from procedure (far return)</summary>
      <description>The RETF instruction transfers control back to a calling procedure by performing a far return, which pops the return instruction pointer and code segment selector from the stack. It can optionally release parameters from the stack and handles transitions between different privilege levels and segments with extensive validation of segment descriptors.</description>
      <operation>RIP := Pop()
CS := Pop()
Optionally: RSP := RSP + imm16</operation>
      <flags-affected>None directly (EFLAGS may be popped during inter-privilege-level returns)</flags-affected>
      <notes>In 64-bit mode, default operation size is 32 bits for far returns. Performs extensive security checks including canonical address validation and segment descriptor verification. The imm16 operand specifies number of bytes to release from stack after return.</notes>
    </documentation>
  </instruction>
  <instruction name="retn" category="CONTROL_FLOW">
    <description>Near return from procedure</description>
  </instruction>
  <instruction name="rol" category="BIT_MANIPULATION">
    <description>Rotate left</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Rotate Left</summary>
      <description>Rotates the bits in the first operand to the left by the count specified in the second operand. Bits shifted out the left end are rotated back into the right end.</description>
      <operation>DEST := DEST rotated left COUNT bits</operation>
      <flags-affected>CF, OF (SF, ZF, AF, PF undefined)</flags-affected>
      <notes>The last bit rotated out is stored in CF. OF is affected only on 1-bit rotates.</notes>
    </documentation>
  </instruction>
  <instruction name="ror" category="BIT_MANIPULATION">
    <description>Rotate right</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Rotate Right</summary>
      <description>Rotates the bits in the first operand to the right by the count specified in the second operand. Bits shifted out the right end are rotated back into the left end.</description>
      <operation>DEST := DEST rotated right COUNT bits</operation>
      <flags-affected>CF, OF (SF, ZF, AF, PF undefined)</flags-affected>
      <notes>The last bit rotated out is stored in CF. OF is affected only on 1-bit rotates.</notes>
    </documentation>
  </instruction>
  <instruction name="rorx" category="BIT_MANIPULATION">
    <description>Rotate right logical without affecting flags (BMI2)</description>
    <variants>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Rotate right logical without affecting flags</summary>
      <description>Rotates the bits of the second operand right by the count value specified in the immediate byte operand without affecting any arithmetic flags. The result is written to the destination register. The rotation amount is masked (5 bits for 32-bit, 6 bits for 64-bit operations).</description>
      <operation>DEST := SRC rotated right by imm8 bits</operation>
      <flags-affected>None</flags-affected>
      <notes>Requires BMI2 CPUID feature flag. Not supported in real mode or virtual-8086 mode. In 64-bit mode, requires VEX.W1 for 64-bit operands. VEX.L must be 0.</notes>
    </documentation>
  </instruction>
  <instruction name="roundpd" category="SIMD">
    <description>Round packed double-precision</description>
  </instruction>
  <instruction name="roundps" category="SIMD">
    <description>Round packed single-precision</description>
  </instruction>
  <instruction name="roundsd" category="SIMD">
    <description>Round scalar double-precision</description>
  </instruction>
  <instruction name="roundss" category="SIMD">
    <description>Round scalar single-precision</description>
  </instruction>
  <instruction name="rsqrtps" category="SIMD">
    <description>Reciprocal square root of packed single-precision</description>
  </instruction>
  <instruction name="rsqrtss" category="SIMD">
    <description>Reciprocal square root of scalar single-precision</description>
  </instruction>
  <instruction name="sahf" category="SYSTEM">
    <description>Store AH into flags</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Store AH into Flags</summary>
      <description>Loads the SF, ZF, AF, PF, and CF flags of the RFLAGS register from the AH register.</description>
      <operation>RFLAGS[SF:ZF:0:AF:0:PF:1:CF] := AH</operation>
      <flags-affected>SF, ZF, AF, PF, CF</flags-affected>
      <notes>Useful for restoring flag state. Bit positions: SF=7, ZF=6, AF=4, PF=2, CF=0.</notes>
    </documentation>
  </instruction>
  <instruction name="sal" category="BIT_MANIPULATION">
    <description>Shift arithmetic left</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Shift Left</summary>
      <description>Shifts the bits in the first operand to the left by the count specified in the second operand. Bits shifted out are stored in the CF flag. Zeros are shifted in on the right.</description>
      <operation>DEST := DEST &lt;&lt; COUNT</operation>
      <flags-affected>CF, OF, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>SHL and SAL are synonyms. The last bit shifted out is stored in CF.</notes>
    </documentation>
  </instruction>
  <instruction name="sar" category="BIT_MANIPULATION">
    <description>Shift arithmetic right</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Shift Arithmetic Right</summary>
      <description>Shifts the bits in the first operand to the right by the count specified in the second operand. The sign bit is preserved (copied into vacated bits on the left).</description>
      <operation>DEST := DEST &gt;&gt; COUNT (arithmetic)</operation>
      <flags-affected>CF, OF, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>Arithmetic shift preserves the sign of the operand. Use SHR for logical shift.</notes>
    </documentation>
  </instruction>
  <instruction name="sarx" category="BIT_MANIPULATION">
    <description>Shift arithmetic right without affecting flags (BMI2)</description>
  </instruction>
  <instruction name="sbb" category="ARITHMETIC">
    <description>Subtract with borrow</description>
    <documentation>
      <summary>Subtract with Borrow</summary>
      <description>Subtracts the source operand and the carry flag (CF) from the destination operand and stores the result in the destination.</description>
      <operation>DEST := DEST - (SRC + CF)</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>Used for multi-precision arithmetic. Typically follows a SUB instruction.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
        <operand type="REG" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="R_M" />
        <operand type="IMM" />
      </variant>
    </variants>
  </instruction>
  <instruction name="scas" category="STRING">
    <description>Scan string</description>
    <variants>
      <variant>
        <operand type="MEM8" />
      </variant>
      <variant>
        <operand type="MEM16" />
      </variant>
      <variant>
        <operand type="MEM32" />
      </variant>
      <variant>
        <operand type="MEM64" />
      </variant>
    </variants>
    <documentation>
      <summary>Scan string by comparing AL/AX/EAX/RAX with memory</summary>
      <description>Compares the value in AL, AX, EAX, or RAX with the byte, word, doubleword, or quadword at the memory location addressed by ES:(R|E)DI. The comparison is performed by subtracting the memory operand from the register operand and setting status flags accordingly. After the comparison, the (R|E)DI register is automatically incremented or decremented based on the Direction Flag (DF) and operand size.</description>
      <operation>TEMP := AL/AX/EAX/RAX - [ES:(R|E)DI]
Set flags according to TEMP
(R|E)DI := (R|E)DI +/- operand_size</operation>
      <flags-affected>OF, SF, ZF, AF, PF, and CF</flags-affected>
      <notes>Can be preceded by REPE/REPZ or REPNE/REPNZ prefixes. Memory operand address is always ES:(R|E)DI (ES cannot be overridden).</notes>
    </documentation>
  </instruction>
  <instruction name="scasb" category="STRING">
    <description>Scan byte string</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Scan String</summary>
      <description>Compares AL/AX/EAX/RAX with the memory location pointed to by RDI, sets flags according to the result, then increments or decrements RDI.</description>
      <operation>temp := AL/AX/EAX/RAX - [RDI]
(Flags set according to temp)
RDI := RDI +/- size</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>Often used with REPE/REPNE to search for a value in memory.</notes>
    </documentation>
  </instruction>
  <instruction name="scasd" category="STRING">
    <description>Scan doubleword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Scan string doubleword by comparing EAX with memory at ES:(R|E)DI</summary>
      <description>Compares the value in the EAX register with the doubleword (32-bit) at the memory location addressed by ES:(R|E)DI. After the comparison, the (R|E)DI register is automatically incremented or decremented by 4 based on the Direction Flag (DF). This is the no-operands form of SCAS for doubleword-sized operations.</description>
      <operation>TEMP := EAX - [ES:(R|E)DI]
Set flags according to TEMP
(R|E)DI := (R|E)DI +/- 4</operation>
      <flags-affected>OF, SF, ZF, AF, PF, and CF</flags-affected>
      <notes>Can be preceded by REPE/REPZ or REPNE/REPNZ prefixes. Memory address is always ES:(R|E)DI.</notes>
    </documentation>
  </instruction>
  <instruction name="scasq" category="STRING">
    <description>Scan quadword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Scan string quadword by comparing RAX with memory at RDI</summary>
      <description>Compares the value in the RAX register with the quadword (64-bit) at the memory location addressed by RDI. After the comparison, the RDI register is automatically incremented or decremented by 8 based on the Direction Flag (DF). This is the no-operands form of SCAS for quadword-sized operations and is only available in 64-bit mode.</description>
      <operation>TEMP := RAX - [ES:RDI]
Set flags according to TEMP
RDI := RDI +/- 8</operation>
      <flags-affected>OF, SF, ZF, AF, PF, and CF</flags-affected>
      <notes>Can be preceded by REPE/REPZ or REPNE/REPNZ prefixes. Only available in 64-bit mode. Requires REX.W prefix.</notes>
    </documentation>
  </instruction>
  <instruction name="scasw" category="STRING">
    <description>Scan word string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Scan string word by comparing AX with memory at ES:(R|E)DI</summary>
      <description>Compares the value in the AX register with the word (16-bit) at the memory location addressed by ES:(R|E)DI. After the comparison, the (R|E)DI register is automatically incremented or decremented by 2 based on the Direction Flag (DF). This is the no-operands form of SCAS for word-sized operations.</description>
      <operation>TEMP := AX - [ES:(R|E)DI]
Set flags according to TEMP
(R|E)DI := (R|E)DI +/- 2</operation>
      <flags-affected>OF, SF, ZF, AF, PF, and CF</flags-affected>
      <notes>Can be preceded by REPE/REPZ or REPNE/REPNZ prefixes. Memory address is always ES:(R|E)DI.</notes>
    </documentation>
  </instruction>
  <instruction name="seta" category="LOGIC">
    <description>Set byte if above (unsigned)</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Above / Set Byte if Not Below or Equal</summary>
      <description>Sets the destination byte to 1 if CF=0 and ZF=0; otherwise sets the destination to 0. Used for unsigned comparisons.</description>
      <operation>if CF = 0 AND ZF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use SETG for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setae" category="LOGIC">
    <description>Set byte if above or equal (unsigned)</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Above or Equal / Set Byte if Not Below / Set Byte if Not Carry</summary>
      <description>Sets the destination byte to 1 if CF=0; otherwise sets the destination to 0. Used for unsigned comparisons.</description>
      <operation>if CF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use SETGE for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setb" category="LOGIC">
    <description>Set byte if below (unsigned)</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Below / Set Byte if Not Above or Equal / Set Byte if Carry</summary>
      <description>Sets the destination byte to 1 if CF=1; otherwise sets the destination to 0. Used for unsigned comparisons.</description>
      <operation>if CF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use SETL for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setbe" category="LOGIC">
    <description>Set byte if below or equal (unsigned)</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Below or Equal / Set Byte if Not Above</summary>
      <description>Sets the destination byte to 1 if CF=1 or ZF=1; otherwise sets the destination to 0. Used for unsigned comparisons.</description>
      <operation>if CF = 1 OR ZF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For unsigned comparisons. Use SETLE for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setc" category="LOGIC">
    <description>Set byte if carry</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if carry</summary>
      <description>Sets the destination byte operand to 1 if the Carry Flag (CF) is set, otherwise sets it to 0. This instruction is commonly used after unsigned arithmetic operations to detect carry/borrow conditions. SETC is an alias for SETB (Set if Below).</description>
      <operation>IF CF = 1 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>SETC is equivalent to SETB and SETNAE. All three test CF=1 but use different mnemonics for code clarity.</notes>
    </documentation>
  </instruction>
  <instruction name="sete" category="LOGIC">
    <description>Set byte if equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Zero / Set Byte if Equal</summary>
      <description>Sets the destination byte to 1 if the ZF flag is set (ZF=1); otherwise sets the destination to 0. Typically used after a CMP or TEST instruction to capture the comparison result.</description>
      <operation>if ZF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>SETZ and SETE are synonyms. Part of the SETcc family of conditional set instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="setg" category="LOGIC">
    <description>Set byte if greater</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Greater / Set Byte if Not Less or Equal</summary>
      <description>Sets the destination byte to 1 if (SF XOR OF)=0 and ZF=0; otherwise sets the destination to 0. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 0 AND ZF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use SETA for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setge" category="LOGIC">
    <description>Set byte if greater or equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Greater or Equal / Set Byte if Not Less</summary>
      <description>Sets the destination byte to 1 if (SF XOR OF)=0; otherwise sets the destination to 0. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use SETAE for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setl" category="LOGIC">
    <description>Set byte if less</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Less / Set Byte if Not Greater or Equal</summary>
      <description>Sets the destination byte to 1 if (SF XOR OF)=1; otherwise sets the destination to 0. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use SETB for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setle" category="LOGIC">
    <description>Set byte if less or equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Less or Equal / Set Byte if Not Greater</summary>
      <description>Sets the destination byte to 1 if (SF XOR OF)=1 or ZF=1; otherwise sets the destination to 0. Used for signed comparisons.</description>
      <operation>if (SF XOR OF) = 1 OR ZF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>For signed comparisons. Use SETBE for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setna" category="LOGIC">
    <description>Set byte if not above</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not above (unsigned &lt;=)</summary>
      <description>Sets the destination byte operand to 1 if the condition 'CF=1 or ZF=1' is true, otherwise sets it to 0. This instruction is used for unsigned comparisons and tests if the first operand is not above (less than or equal to) the second operand. SETNA is an alias for SETBE (Set if Below or Equal).</description>
      <operation>IF (CF = 1 OR ZF = 1) THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads CF and ZF)</flags-affected>
      <notes>SETNA is equivalent to SETBE. Both test CF=1 or ZF=1 for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnae" category="LOGIC">
    <description>Set byte if not above or equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not above or equal (unsigned &lt;)</summary>
      <description>Sets the destination byte operand to 1 if the Carry Flag (CF) is set, otherwise sets it to 0. This instruction is used for unsigned comparisons and tests if the first operand is not above or equal to (less than) the second operand. SETNAE is an alias for SETB and SETC.</description>
      <operation>IF CF = 1 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>SETNAE is equivalent to SETB and SETC. All three test CF=1. Use SETNAE for 'not above or equal' semantics in unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnb" category="LOGIC">
    <description>Set byte if not below</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not below (unsigned &gt;=)</summary>
      <description>Sets the destination byte operand to 1 if the Carry Flag (CF) is clear, otherwise sets it to 0. This instruction is used for unsigned comparisons and tests if the first operand is not below (greater than or equal to) the second operand. SETNB is an alias for SETAE and SETNC.</description>
      <operation>IF CF = 0 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>SETNB is equivalent to SETAE and SETNC. All three test CF=0. Use SETNB for 'not below' semantics in unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnbe" category="LOGIC">
    <description>Set byte if not below or equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not below or equal (unsigned &gt;)</summary>
      <description>Sets the destination byte operand to 1 if the condition 'CF=0 and ZF=0' is true, otherwise sets it to 0. This instruction is used for unsigned comparisons and tests if the first operand is not below or equal to (greater than) the second operand. SETNBE is an alias for SETA (Set if Above).</description>
      <operation>IF (CF = 0 AND ZF = 0) THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads CF and ZF)</flags-affected>
      <notes>SETNBE is equivalent to SETA. Both test CF=0 and ZF=0 for unsigned comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnc" category="LOGIC">
    <description>Set byte if not carry</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not carry</summary>
      <description>Sets the destination byte operand to 1 if the Carry Flag (CF) is clear, otherwise sets it to 0. This instruction is commonly used after unsigned arithmetic operations to detect the absence of carry/borrow conditions. SETNC is an alias for SETNB (Set if Not Below).</description>
      <operation>IF CF = 0 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads CF)</flags-affected>
      <notes>SETNC is equivalent to SETNB and SETAE. All three test CF=0 but use different mnemonics for code clarity.</notes>
    </documentation>
  </instruction>
  <instruction name="setne" category="LOGIC">
    <description>Set byte if not equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Not Equal / Set Byte if Not Zero</summary>
      <description>Sets the destination byte to 1 if the ZF flag is clear (ZF=0); otherwise sets the destination to 0.</description>
      <operation>if ZF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>SETNE and SETNZ are synonyms. Part of the SETcc family of conditional set instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="setng" category="LOGIC">
    <description>Set byte if not greater</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not greater (signed &lt;=)</summary>
      <description>Sets the destination byte operand to 1 if the condition 'ZF=1 or SF≠OF' is true, otherwise sets it to 0. This instruction is used for signed comparisons and tests if the first operand is not greater than (less than or equal to) the second operand. SETNG is an alias for SETLE (Set if Less or Equal).</description>
      <operation>IF (ZF = 1 OR SF ≠ OF) THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads ZF, SF, and OF)</flags-affected>
      <notes>SETNG is equivalent to SETLE. Both test ZF=1 or SF≠OF for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnge" category="LOGIC">
    <description>Set byte if not greater or equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not greater or equal (signed &lt;)</summary>
      <description>Sets the destination byte operand to 1 if the Sign Flag does not equal the Overflow Flag (SF≠OF), otherwise sets it to 0. This instruction is used for signed comparisons and tests if the first operand is not greater than or equal to (less than) the second operand. SETNGE is an alias for SETL (Set if Less).</description>
      <operation>IF SF ≠ OF THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads SF and OF)</flags-affected>
      <notes>SETNGE is equivalent to SETL. Both test SF≠OF for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnl" category="LOGIC">
    <description>Set byte if not less</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not less (signed &gt;=)</summary>
      <description>Sets the destination byte operand to 1 if the Sign Flag equals the Overflow Flag (SF=OF), otherwise sets it to 0. This instruction is used for signed comparisons and tests if the first operand is not less than (greater than or equal to) the second operand. SETNL is an alias for SETGE (Set if Greater or Equal).</description>
      <operation>IF SF = OF THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads SF and OF)</flags-affected>
      <notes>SETNL is equivalent to SETGE. Both test SF=OF for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setnle" category="LOGIC">
    <description>Set byte if not less or equal</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not less or equal (signed &gt;)</summary>
      <description>Sets the destination byte operand to 1 if the condition 'ZF=0 and SF=OF' is true, otherwise sets it to 0. This instruction is used for signed comparisons and tests if the first operand is not less than or equal to (greater than) the second operand. SETNLE is an alias for SETG (Set if Greater).</description>
      <operation>IF (ZF = 0 AND SF = OF) THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads ZF, SF, and OF)</flags-affected>
      <notes>SETNLE is equivalent to SETG. Both test ZF=0 and SF=OF for signed comparisons.</notes>
    </documentation>
  </instruction>
  <instruction name="setno" category="LOGIC">
    <description>Set byte if not overflow</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Not Overflow</summary>
      <description>Sets the destination byte to 1 if OF=0; otherwise sets the destination to 0.</description>
      <operation>if OF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>Sets if the last arithmetic operation did not result in overflow.</notes>
    </documentation>
  </instruction>
  <instruction name="setnp" category="LOGIC">
    <description>Set byte if not parity</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Not Parity / Set Byte if Parity Odd</summary>
      <description>Sets the destination byte to 1 if PF=0; otherwise sets the destination to 0.</description>
      <operation>if PF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>Sets if the number of set bits in the low byte of the result is odd.</notes>
    </documentation>
  </instruction>
  <instruction name="setns" category="LOGIC">
    <description>Set byte if not sign</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Not Sign</summary>
      <description>Sets the destination byte to 1 if SF=0; otherwise sets the destination to 0.</description>
      <operation>if SF = 0 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>Sets if the result of the last operation was positive or zero.</notes>
    </documentation>
  </instruction>
  <instruction name="setnz" category="LOGIC">
    <description>Set byte if not zero</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if not zero</summary>
      <description>Sets the destination byte operand to 1 if the Zero Flag (ZF) is clear, otherwise sets it to 0. This instruction is typically used after a comparison or arithmetic operation to test for inequality or non-zero results. SETNZ is an alias for SETNE (Set if Not Equal).</description>
      <operation>IF ZF = 0 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads ZF)</flags-affected>
      <notes>SETNZ is equivalent to SETNE. Both test ZF=0. SETNZ emphasizes testing for non-zero, SETNE emphasizes inequality.</notes>
    </documentation>
  </instruction>
  <instruction name="seto" category="LOGIC">
    <description>Set byte if overflow</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Overflow</summary>
      <description>Sets the destination byte to 1 if OF=1; otherwise sets the destination to 0.</description>
      <operation>if OF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>Sets if the last arithmetic operation resulted in overflow.</notes>
    </documentation>
  </instruction>
  <instruction name="setp" category="LOGIC">
    <description>Set byte if parity</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Parity / Set Byte if Parity Even</summary>
      <description>Sets the destination byte to 1 if PF=1; otherwise sets the destination to 0.</description>
      <operation>if PF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>Sets if the number of set bits in the low byte of the result is even.</notes>
    </documentation>
  </instruction>
  <instruction name="setpe" category="LOGIC">
    <description>Set byte if parity even</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if parity even</summary>
      <description>Sets the destination byte operand to 1 if the Parity Flag (PF) is set, otherwise sets it to 0. This instruction tests for even parity, where the low-order 8 bits of the result contain an even number of 1 bits. SETPE is an alias for SETP (Set if Parity).</description>
      <operation>IF PF = 1 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads PF)</flags-affected>
      <notes>SETPE is equivalent to SETP. Both test PF=1. In 64-bit mode with REX prefix, cannot use AH, BH, CH, DH registers.</notes>
    </documentation>
  </instruction>
  <instruction name="setpo" category="LOGIC">
    <description>Set byte if parity odd</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set byte if parity odd</summary>
      <description>Sets the destination byte operand to 1 if the Parity Flag (PF) is clear, otherwise sets it to 0. This instruction tests for odd parity, where the low-order 8 bits of the result contain an odd number of 1 bits. SETPO is an alias for SETNP (Set if Not Parity).</description>
      <operation>IF PF = 0 THEN
  DEST := 1
ELSE
  DEST := 0</operation>
      <flags-affected>None (reads PF)</flags-affected>
      <notes>SETPO is equivalent to SETNP. Both test PF=0. In 64-bit mode with REX prefix, cannot use AH, BH, CH, DH registers.</notes>
    </documentation>
  </instruction>
  <instruction name="sets" category="LOGIC">
    <description>Set byte if sign</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Sign</summary>
      <description>Sets the destination byte to 1 if SF=1; otherwise sets the destination to 0.</description>
      <operation>if SF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>Sets if the result of the last operation was negative.</notes>
    </documentation>
  </instruction>
  <instruction name="setz" category="LOGIC">
    <description>Set byte if zero</description>
    <variants>
      <variant>
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="R_M8" />
      </variant>
    </variants>
    <documentation>
      <summary>Set Byte if Zero / Set Byte if Equal</summary>
      <description>Sets the destination byte to 1 if the ZF flag is set (ZF=1); otherwise sets the destination to 0. Typically used after a CMP or TEST instruction to capture the comparison result.</description>
      <operation>if ZF = 1 then
  DEST := 1
else
  DEST := 0</operation>
      <flags-affected>None</flags-affected>
      <notes>SETZ and SETE are synonyms. Part of the SETcc family of conditional set instructions.</notes>
    </documentation>
  </instruction>
  <instruction name="sfence" category="SYSTEM">
    <description>Store fence</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Store Fence</summary>
      <description>Performs a serializing operation on all store-to-memory instructions that were issued prior to the SFENCE instruction. Ensures that all previous store operations are complete before any subsequent store operation.</description>
      <operation>(serializing operation for stores)</operation>
      <flags-affected>None</flags-affected>
      <notes>Ensures ordering of store operations. Does not affect load operations.</notes>
    </documentation>
  </instruction>
  <instruction name="sgdt" category="SYSTEM">
    <description>Store global descriptor table register</description>
  </instruction>
  <instruction name="sha1msg1" category="CRYPTO">
    <description>SHA1 message schedule 1</description>
  </instruction>
  <instruction name="sha1msg2" category="CRYPTO">
    <description>SHA1 message schedule 2</description>
  </instruction>
  <instruction name="sha1nexte" category="CRYPTO">
    <description>SHA1 next E</description>
  </instruction>
  <instruction name="sha1rnds4" category="CRYPTO">
    <description>SHA1 rounds 4</description>
  </instruction>
  <instruction name="sha256msg1" category="CRYPTO">
    <description>SHA256 message schedule 1</description>
  </instruction>
  <instruction name="sha256msg2" category="CRYPTO">
    <description>SHA256 message schedule 2</description>
  </instruction>
  <instruction name="sha256rnds2" category="CRYPTO">
    <description>SHA256 rounds 2</description>
  </instruction>
  <instruction name="shl" category="BIT_MANIPULATION">
    <description>Shift left</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Shift Left</summary>
      <description>Shifts the bits in the first operand to the left by the count specified in the second operand. Bits shifted out are stored in the CF flag. Zeros are shifted in on the right.</description>
      <operation>DEST := DEST &lt;&lt; COUNT</operation>
      <flags-affected>CF, OF, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>SHL and SAL are synonyms. The last bit shifted out is stored in CF.</notes>
    </documentation>
  </instruction>
  <instruction name="shld" category="BIT_MANIPULATION">
    <description>Double precision shift left</description>
    <variants>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
        <operand type="CL" />
      </variant>
    </variants>
    <documentation>
      <summary>Double precision shift left</summary>
      <description>Performs a multi-precision left shift operation by shifting the destination operand left while bringing in bits from the source register. The shift count can be specified as an immediate value or in the CL register. This instruction is useful for multi-precision shifts of 64 bits or more.</description>
      <operation>DEST := DEST &lt;&lt; count with bits from SRC</operation>
      <flags-affected>CF is set to last bit shifted out; OF set if 1-bit shift causes sign change; SF, ZF, PF set according to result; AF undefined</flags-affected>
      <notes>In non-64-bit modes, only bits 0-4 of count are used (masked to 5 bits). In 64-bit mode with REX.W, count is masked to 6 bits.</notes>
    </documentation>
  </instruction>
  <instruction name="shlx" category="BIT_MANIPULATION">
    <description>Shift logical left without affecting flags (BMI2)</description>
  </instruction>
  <instruction name="shr" category="BIT_MANIPULATION">
    <description>Shift right</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM1" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM8" />
      </variant>
    </variants>
    <documentation>
      <summary>Shift Right (Logical)</summary>
      <description>Shifts the bits in the first operand to the right by the count specified in the second operand. Bits shifted out are stored in the CF flag. Zeros are shifted in on the left.</description>
      <operation>DEST := DEST &gt;&gt; COUNT (logical)</operation>
      <flags-affected>CF, OF, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>Logical shift (fills with zeros). Use SAR for arithmetic shift.</notes>
    </documentation>
  </instruction>
  <instruction name="shrd" category="BIT_MANIPULATION">
    <description>Double precision shift right</description>
    <variants>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
        <operand type="CL" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
        <operand type="CL" />
      </variant>
    </variants>
    <documentation>
      <summary>Double precision shift right</summary>
      <description>Performs a double-precision right shift operation by shifting the destination operand right while bringing in bits from the source register starting with the most significant bit. The shift count can be specified as an immediate value or in the CL register. This instruction is useful for multi-precision shifts of 64 bits or more.</description>
      <operation>DEST := DEST &gt;&gt; count with bits from SRC</operation>
      <flags-affected>CF is set to last bit shifted out; OF set if 1-bit shift causes sign change; SF, ZF, PF set according to result; AF undefined</flags-affected>
      <notes>In 64-bit mode, default operation size is 32 bits. REX.W prefix enables 64-bit operation. If count exceeds operand size, result is undefined.</notes>
    </documentation>
  </instruction>
  <instruction name="shrx" category="BIT_MANIPULATION">
    <description>Shift logical right without affecting flags (BMI2)</description>
  </instruction>
  <instruction name="shufpd" category="SIMD">
    <description>Shuffle packed double-precision</description>
  </instruction>
  <instruction name="shufps" category="SIMD">
    <description>Shuffle packed single-precision</description>
  </instruction>
  <instruction name="sidt" category="SYSTEM">
    <description>Store interrupt descriptor table register</description>
  </instruction>
  <instruction name="sldt" category="SYSTEM">
    <description>Store local descriptor table register</description>
  </instruction>
  <instruction name="smsw" category="SYSTEM">
    <description>Store machine status word</description>
  </instruction>
  <instruction name="sqrtpd" category="SIMD">
    <description>Square root of packed double-precision</description>
  </instruction>
  <instruction name="sqrtps" category="SIMD">
    <description>Square root of packed single-precision</description>
  </instruction>
  <instruction name="sqrtsd" category="SIMD">
    <description>Square root of scalar double-precision</description>
  </instruction>
  <instruction name="sqrtss" category="SIMD">
    <description>Square root of scalar single-precision</description>
  </instruction>
  <instruction name="stc" category="SYSTEM">
    <description>Set carry flag</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Set Carry Flag</summary>
      <description>Sets the CF (carry flag) in the RFLAGS register.</description>
      <operation>CF := 1</operation>
      <flags-affected>CF (set)</flags-affected>
      <notes>Can be used to set up the carry flag for subsequent operations.</notes>
    </documentation>
  </instruction>
  <instruction name="std" category="SYSTEM">
    <description>Set direction flag</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Set Direction Flag</summary>
      <description>Sets the DF (direction flag) in the RFLAGS register. When DF is set, string operations decrement the pointer registers (RSI and RDI).</description>
      <operation>DF := 1</operation>
      <flags-affected>DF (set)</flags-affected>
      <notes>Should be called before string operations that process memory in decreasing address order.</notes>
    </documentation>
  </instruction>
  <instruction name="sti" category="SYSTEM">
    <description>Set interrupt flag</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Set Interrupt Flag</summary>
      <description>Sets the IF (interrupt flag) in the RFLAGS register. When the IF flag is set, the processor responds to maskable external interrupts. This instruction is privileged (CPL=0).</description>
      <operation>IF := 1</operation>
      <flags-affected>IF (set)</flags-affected>
      <notes>Privileged instruction. Only affects maskable interrupts; non-maskable interrupts are not affected.</notes>
    </documentation>
  </instruction>
  <instruction name="stmxcsr" category="SIMD">
    <description>Store MXCSR register</description>
  </instruction>
  <instruction name="stos" category="STRING">
    <description>Store string</description>
  </instruction>
  <instruction name="stosb" category="STRING">
    <description>Store byte string</description>
    <variants>
      <variant />
      <variant />
      <variant />
      <variant />
    </variants>
    <documentation>
      <summary>Store String</summary>
      <description>Stores the value from AL/AX/EAX/RAX to the memory location pointed to by RDI, then increments or decrements (depending on DF) RDI.</description>
      <operation>[RDI] := AL/AX/EAX/RAX
RDI := RDI +/- size</operation>
      <flags-affected>None</flags-affected>
      <notes>Often used with REP prefix for filling memory blocks. Direction controlled by DF flag.</notes>
    </documentation>
  </instruction>
  <instruction name="stosd" category="STRING">
    <description>Store doubleword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Store string doubleword from EAX to memory at ES:(R|E)DI</summary>
      <description>Stores the doubleword (32-bit) value from the EAX register to the memory location addressed by ES:(R|E)DI. After the store, the (R|E)DI register is automatically incremented or decremented by 4 based on the Direction Flag (DF). This is the no-operands form of STOS for doubleword-sized operations.</description>
      <operation>[ES:(R|E)DI] := EAX
(R|E)DI := (R|E)DI +/- 4</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block stores. Memory address is always ES:(R|E)DI (ES cannot be overridden).</notes>
    </documentation>
  </instruction>
  <instruction name="stosq" category="STRING">
    <description>Store quadword string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Store string quadword from RAX to memory at RDI</summary>
      <description>Stores the quadword (64-bit) value from the RAX register to the memory location addressed by RDI. After the store, the RDI register is automatically incremented or decremented by 8 based on the Direction Flag (DF). This is the no-operands form of STOS for quadword-sized operations and is only available in 64-bit mode.</description>
      <operation>[ES:RDI] := RAX
RDI := RDI +/- 8</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block stores. Only available in 64-bit mode. REP STOSQ is highly efficient for initializing large memory blocks.</notes>
    </documentation>
  </instruction>
  <instruction name="stosw" category="STRING">
    <description>Store word string</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Store string word from AX to memory at ES:(R|E)DI</summary>
      <description>Stores the word (16-bit) value from the AX register to the memory location addressed by ES:(R|E)DI. After the store, the (R|E)DI register is automatically incremented or decremented by 2 based on the Direction Flag (DF). This is the no-operands form of STOS for word-sized operations.</description>
      <operation>[ES:(R|E)DI] := AX
(R|E)DI := (R|E)DI +/- 2</operation>
      <flags-affected>None</flags-affected>
      <notes>Can be preceded by REP prefix for block stores. Memory address is always ES:(R|E)DI (ES cannot be overridden).</notes>
    </documentation>
  </instruction>
  <instruction name="str" category="SYSTEM">
    <description>Store task register</description>
  </instruction>
  <instruction name="sub" category="ARITHMETIC">
    <description>Subtract</description>
    <documentation>
      <summary>Subtract</summary>
      <description>Subtracts the source operand (second operand) from the destination operand (first operand) and stores the result in the destination operand. The destination operand can be a register or memory location. The source operand can be an immediate value, register, or memory location.</description>
      <operation>DEST := DEST - SRC</operation>
      <flags-affected>OF, SF, ZF, AF, CF, PF</flags-affected>
      <notes>The OF, SF, ZF, AF, CF, and PF flags are set according to the result.</notes>
    </documentation>
    <variants>
      <variant>
        <operand type="R_M" />
        <operand type="REG" />
      </variant>
      <variant>
        <operand type="REG" />
        <operand type="R_M" />
      </variant>
      <variant>
        <operand type="R_M" />
        <operand type="IMM" />
      </variant>
    </variants>
  </instruction>
  <instruction name="subpd" category="SIMD">
    <description>Subtract packed double-precision</description>
  </instruction>
  <instruction name="subps" category="SIMD">
    <description>Subtract packed single-precision</description>
  </instruction>
  <instruction name="subsd" category="SIMD">
    <description>Subtract scalar double-precision</description>
  </instruction>
  <instruction name="subss" category="SIMD">
    <description>Subtract scalar single-precision</description>
  </instruction>
  <instruction name="swapgs" category="SYSTEM">
    <description>Swap GS base register (64-bit mode only)</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Swap GS Base Register</summary>
      <description>Exchanges the current value of the GS base register with the value in the KernelGSbase MSR (MSR address C0000102h). This instruction is typically used to switch between user and kernel GS base values during system calls or interrupts. This instruction is privileged (CPL=0) and only available in 64-bit mode.</description>
      <operation>temp := GS.base
GS.base := KernelGSbase
KernelGSbase := temp</operation>
      <flags-affected>None</flags-affected>
      <notes>Privileged instruction. Only available in 64-bit mode. Used for fast context switching between user and kernel mode.</notes>
    </documentation>
  </instruction>
  <instruction name="syscall" category="SYSTEM">
    <description>System call</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Fast System Call</summary>
      <description>Fast call to privilege level 0 system procedures. Transfers control to the operating system kernel.</description>
      <operation>RCX := RIP
RIP := IA32_LSTAR
R11 := RFLAGS</operation>
      <flags-affected>None (RF cleared in RFLAGS)</flags-affected>
      <notes>In 64-bit mode, system call number is in RAX. Arguments are in RDI, RSI, RDX, R10, R8, R9.</notes>
    </documentation>
  </instruction>
  <instruction name="sysenter" category="SYSTEM">
    <description>Fast system call</description>
  </instruction>
  <instruction name="sysexit" category="SYSTEM">
    <description>Fast return from system call</description>
  </instruction>
  <instruction name="sysret" category="SYSTEM">
    <description>Return from system call</description>
  </instruction>
  <instruction name="test" category="LOGIC">
    <description>Logical test</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM32" />
      </variant>
    </variants>
    <documentation>
      <summary>Logical Compare</summary>
      <description>Computes the bit-wise logical AND of first operand and the second operand. The flags SF, ZF, and PF are set according to the result. The result is then discarded.</description>
      <operation>temp := DEST AND SRC
(Flags set according to temp, temp discarded)</operation>
      <flags-affected>OF=0, CF=0, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>Used to test if specific bits are set without modifying the operands.</notes>
    </documentation>
  </instruction>
  <instruction name="tzcnt" category="BIT_MANIPULATION">
    <description>Count trailing zero bits (BMI1)</description>
    <variants>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Count the number of trailing zero bits in the source operand</summary>
      <description>Counts the number of trailing (least significant) zero bits in the source operand and returns the result in the destination operand. When the source operand is zero, TZCNT returns the operand size, which differs from the BSF instruction. On processors that don't support TZCNT, it executes as BSF.</description>
      <operation>DEST := Count of trailing zero bits in SRC</operation>
      <flags-affected>ZF is set if output is zero; CF is set if input was zero; OF, SF, PF, AF are undefined</flags-affected>
      <notes>Requires BMI1 CPUID feature flag. Supported in both 32-bit and 64-bit modes. On unsupporting processors, executes as BSF instruction.</notes>
    </documentation>
  </instruction>
  <instruction name="ucomisd" category="SIMD">
    <description>Compare scalar unordered double-precision</description>
  </instruction>
  <instruction name="ucomiss" category="SIMD">
    <description>Compare scalar unordered single-precision</description>
  </instruction>
  <instruction name="ud0" category="SYSTEM">
    <description>Undefined instruction 0</description>
  </instruction>
  <instruction name="ud1" category="SYSTEM">
    <description>Undefined instruction 1</description>
  </instruction>
  <instruction name="ud2" category="SYSTEM">
    <description>Undefined instruction 2</description>
  </instruction>
  <instruction name="unpckhpd" category="SIMD">
    <description>Unpack high packed double-precision</description>
  </instruction>
  <instruction name="unpckhps" category="SIMD">
    <description>Unpack high packed single-precision</description>
  </instruction>
  <instruction name="unpcklpd" category="SIMD">
    <description>Unpack low packed double-precision</description>
  </instruction>
  <instruction name="unpcklps" category="SIMD">
    <description>Unpack low packed single-precision</description>
  </instruction>
  <instruction name="vaddpd" category="SIMD">
    <description>Add packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vaddps" category="SIMD">
    <description>Add packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vaddsd" category="SIMD">
    <description>Add scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vaddss" category="SIMD">
    <description>Add scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vaddsubpd" category="SIMD">
    <description>Add/subtract packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vaddsubps" category="SIMD">
    <description>Add/subtract packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vaesdec" category="CRYPTO">
    <description>AES decrypt single round (AVX)</description>
  </instruction>
  <instruction name="vaesdeclast" category="CRYPTO">
    <description>AES decrypt last round (AVX)</description>
  </instruction>
  <instruction name="vaesenc" category="CRYPTO">
    <description>AES encrypt single round (AVX)</description>
  </instruction>
  <instruction name="vaesenclast" category="CRYPTO">
    <description>AES encrypt last round (AVX)</description>
  </instruction>
  <instruction name="vaesimc" category="CRYPTO">
    <description>AES inverse mix columns (AVX)</description>
  </instruction>
  <instruction name="vaeskeygenassist" category="CRYPTO">
    <description>AES key generation assist (AVX)</description>
  </instruction>
  <instruction name="valignd" category="SIMD">
    <description>Align doubleword vectors</description>
  </instruction>
  <instruction name="valignq" category="SIMD">
    <description>Align quadword vectors</description>
  </instruction>
  <instruction name="vandnpd" category="SIMD">
    <description>Bitwise AND NOT of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vandnps" category="SIMD">
    <description>Bitwise AND NOT of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vandpd" category="SIMD">
    <description>Bitwise AND of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vandps" category="SIMD">
    <description>Bitwise AND of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vblendpd" category="SIMD">
    <description>Blend packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vblendps" category="SIMD">
    <description>Blend packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vblendvpd" category="SIMD">
    <description>Variable blend packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vblendvps" category="SIMD">
    <description>Variable blend packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vbroadcastf128" category="SIMD">
    <description>Broadcast 128 bits (AVX)</description>
  </instruction>
  <instruction name="vbroadcasti128" category="SIMD">
    <description>Broadcast 128 bits of integer data (AVX2)</description>
  </instruction>
  <instruction name="vbroadcastsd" category="SIMD">
    <description>Broadcast double-precision to all elements (AVX)</description>
  </instruction>
  <instruction name="vbroadcastss" category="SIMD">
    <description>Broadcast single-precision to all elements (AVX)</description>
  </instruction>
  <instruction name="vcmppd" category="SIMD">
    <description>Compare packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vcmpps" category="SIMD">
    <description>Compare packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vcmpsd" category="SIMD">
    <description>Compare scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vcmpss" category="SIMD">
    <description>Compare scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vcomisd" category="SIMD">
    <description>Compare scalar ordered double-precision (AVX)</description>
  </instruction>
  <instruction name="vcomiss" category="SIMD">
    <description>Compare scalar ordered single-precision (AVX)</description>
  </instruction>
  <instruction name="vcompresspd" category="SIMD">
    <description>Store sparse packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vcompressps" category="SIMD">
    <description>Store sparse packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vcvtdq2pd" category="SIMD">
    <description>Convert packed dword integers to packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtdq2ps" category="SIMD">
    <description>Convert packed dword integers to packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtpd2dq" category="SIMD">
    <description>Convert packed double-precision to packed dword integers (AVX)</description>
  </instruction>
  <instruction name="vcvtpd2ps" category="SIMD">
    <description>Convert packed double-precision to packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtph2ps" category="SIMD">
    <description>Convert packed half-precision to single-precision</description>
  </instruction>
  <instruction name="vcvtps2dq" category="SIMD">
    <description>Convert packed single-precision to packed dword integers (AVX)</description>
  </instruction>
  <instruction name="vcvtps2pd" category="SIMD">
    <description>Convert packed single-precision to packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtps2ph" category="SIMD">
    <description>Convert packed single-precision to half-precision</description>
  </instruction>
  <instruction name="vcvtsd2si" category="SIMD">
    <description>Convert scalar double-precision to dword integer (AVX)</description>
  </instruction>
  <instruction name="vcvtsd2ss" category="SIMD">
    <description>Convert scalar double-precision to scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtsi2sd" category="SIMD">
    <description>Convert dword integer to scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtsi2ss" category="SIMD">
    <description>Convert dword integer to scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtss2sd" category="SIMD">
    <description>Convert scalar single-precision to scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vcvtss2si" category="SIMD">
    <description>Convert scalar single-precision to dword integer (AVX)</description>
  </instruction>
  <instruction name="vcvttpd2dq" category="SIMD">
    <description>Convert with truncation packed double-precision to packed dword integers (AVX)</description>
  </instruction>
  <instruction name="vcvttps2dq" category="SIMD">
    <description>Convert with truncation packed single-precision to packed dword integers (AVX)</description>
  </instruction>
  <instruction name="vcvttsd2si" category="SIMD">
    <description>Convert with truncation scalar double-precision to dword integer (AVX)</description>
  </instruction>
  <instruction name="vcvttss2si" category="SIMD">
    <description>Convert with truncation scalar single-precision to dword integer (AVX)</description>
  </instruction>
  <instruction name="vdivpd" category="SIMD">
    <description>Divide packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vdivps" category="SIMD">
    <description>Divide packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vdivsd" category="SIMD">
    <description>Divide scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vdivss" category="SIMD">
    <description>Divide scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vdppd" category="SIMD">
    <description>Dot product of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vdpps" category="SIMD">
    <description>Dot product of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="verr" category="SYSTEM">
    <description>Verify segment for reading</description>
  </instruction>
  <instruction name="verw" category="SYSTEM">
    <description>Verify segment for writing</description>
  </instruction>
  <instruction name="vexpandpd" category="SIMD">
    <description>Load sparse packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vexpandps" category="SIMD">
    <description>Load sparse packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vextractf128" category="SIMD">
    <description>Extract 128 bits (AVX)</description>
  </instruction>
  <instruction name="vextracti128" category="SIMD">
    <description>Extract 128 bits of integer data (AVX2)</description>
  </instruction>
  <instruction name="vextractps" category="SIMD">
    <description>Extract packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vfixupimmpd" category="SIMD">
    <description>Fix up special packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vfixupimmps" category="SIMD">
    <description>Fix up special packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vfixupimmsd" category="SIMD">
    <description>Fix up special scalar double-precision floating-point value</description>
  </instruction>
  <instruction name="vfixupimmss" category="SIMD">
    <description>Fix up special scalar single-precision floating-point value</description>
  </instruction>
  <instruction name="vfmadd132pd" category="SIMD">
    <description>Fused multiply-add packed double-precision (132 form)</description>
  </instruction>
  <instruction name="vfmadd132ps" category="SIMD">
    <description>Fused multiply-add packed single-precision (132 form)</description>
  </instruction>
  <instruction name="vfmadd132sd" category="SIMD">
    <description>Fused multiply-add scalar double-precision (132 form)</description>
  </instruction>
  <instruction name="vfmadd132ss" category="SIMD">
    <description>Fused multiply-add scalar single-precision (132 form)</description>
  </instruction>
  <instruction name="vfmadd213pd" category="SIMD">
    <description>Fused multiply-add packed double-precision (213 form)</description>
  </instruction>
  <instruction name="vfmadd213ps" category="SIMD">
    <description>Fused multiply-add packed single-precision (213 form)</description>
  </instruction>
  <instruction name="vfmadd213sd" category="SIMD">
    <description>Fused multiply-add scalar double-precision (213 form)</description>
  </instruction>
  <instruction name="vfmadd213ss" category="SIMD">
    <description>Fused multiply-add scalar single-precision (213 form)</description>
  </instruction>
  <instruction name="vfmadd231pd" category="SIMD">
    <description>Fused multiply-add packed double-precision (231 form)</description>
  </instruction>
  <instruction name="vfmadd231ps" category="SIMD">
    <description>Fused multiply-add packed single-precision (231 form)</description>
  </instruction>
  <instruction name="vfmadd231sd" category="SIMD">
    <description>Fused multiply-add scalar double-precision (231 form)</description>
  </instruction>
  <instruction name="vfmadd231ss" category="SIMD">
    <description>Fused multiply-add scalar single-precision (231 form)</description>
  </instruction>
  <instruction name="vfmaddsub132pd" category="SIMD">
    <description>Fused multiply-add/subtract packed double-precision (132 form)</description>
  </instruction>
  <instruction name="vfmaddsub132ps" category="SIMD">
    <description>Fused multiply-add/subtract packed single-precision (132 form)</description>
  </instruction>
  <instruction name="vfmaddsub213pd" category="SIMD">
    <description>Fused multiply-add/subtract packed double-precision (213 form)</description>
  </instruction>
  <instruction name="vfmaddsub213ps" category="SIMD">
    <description>Fused multiply-add/subtract packed single-precision (213 form)</description>
  </instruction>
  <instruction name="vfmaddsub231pd" category="SIMD">
    <description>Fused multiply-add/subtract packed double-precision (231 form)</description>
  </instruction>
  <instruction name="vfmaddsub231ps" category="SIMD">
    <description>Fused multiply-add/subtract packed single-precision (231 form)</description>
  </instruction>
  <instruction name="vfmsub132pd" category="SIMD">
    <description>Fused multiply-subtract packed double-precision (132 form)</description>
  </instruction>
  <instruction name="vfmsub132ps" category="SIMD">
    <description>Fused multiply-subtract packed single-precision (132 form)</description>
  </instruction>
  <instruction name="vfmsub132sd" category="SIMD">
    <description>Fused multiply-subtract scalar double-precision (132 form)</description>
  </instruction>
  <instruction name="vfmsub132ss" category="SIMD">
    <description>Fused multiply-subtract scalar single-precision (132 form)</description>
  </instruction>
  <instruction name="vfmsub213pd" category="SIMD">
    <description>Fused multiply-subtract packed double-precision (213 form)</description>
  </instruction>
  <instruction name="vfmsub213ps" category="SIMD">
    <description>Fused multiply-subtract packed single-precision (213 form)</description>
  </instruction>
  <instruction name="vfmsub213sd" category="SIMD">
    <description>Fused multiply-subtract scalar double-precision (213 form)</description>
  </instruction>
  <instruction name="vfmsub213ss" category="SIMD">
    <description>Fused multiply-subtract scalar single-precision (213 form)</description>
  </instruction>
  <instruction name="vfmsub231pd" category="SIMD">
    <description>Fused multiply-subtract packed double-precision (231 form)</description>
  </instruction>
  <instruction name="vfmsub231ps" category="SIMD">
    <description>Fused multiply-subtract packed single-precision (231 form)</description>
  </instruction>
  <instruction name="vfmsub231sd" category="SIMD">
    <description>Fused multiply-subtract scalar double-precision (231 form)</description>
  </instruction>
  <instruction name="vfmsub231ss" category="SIMD">
    <description>Fused multiply-subtract scalar single-precision (231 form)</description>
  </instruction>
  <instruction name="vfmsubadd132pd" category="SIMD">
    <description>Fused multiply-subtract/add packed double-precision (132 form)</description>
  </instruction>
  <instruction name="vfmsubadd132ps" category="SIMD">
    <description>Fused multiply-subtract/add packed single-precision (132 form)</description>
  </instruction>
  <instruction name="vfmsubadd213pd" category="SIMD">
    <description>Fused multiply-subtract/add packed double-precision (213 form)</description>
  </instruction>
  <instruction name="vfmsubadd213ps" category="SIMD">
    <description>Fused multiply-subtract/add packed single-precision (213 form)</description>
  </instruction>
  <instruction name="vfmsubadd231pd" category="SIMD">
    <description>Fused multiply-subtract/add packed double-precision (231 form)</description>
  </instruction>
  <instruction name="vfmsubadd231ps" category="SIMD">
    <description>Fused multiply-subtract/add packed single-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmadd132pd" category="SIMD">
    <description>Fused negative multiply-add packed double-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmadd132ps" category="SIMD">
    <description>Fused negative multiply-add packed single-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmadd132sd" category="SIMD">
    <description>Fused negative multiply-add scalar double-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmadd132ss" category="SIMD">
    <description>Fused negative multiply-add scalar single-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmadd213pd" category="SIMD">
    <description>Fused negative multiply-add packed double-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmadd213ps" category="SIMD">
    <description>Fused negative multiply-add packed single-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmadd213sd" category="SIMD">
    <description>Fused negative multiply-add scalar double-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmadd213ss" category="SIMD">
    <description>Fused negative multiply-add scalar single-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmadd231pd" category="SIMD">
    <description>Fused negative multiply-add packed double-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmadd231ps" category="SIMD">
    <description>Fused negative multiply-add packed single-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmadd231sd" category="SIMD">
    <description>Fused negative multiply-add scalar double-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmadd231ss" category="SIMD">
    <description>Fused negative multiply-add scalar single-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmsub132pd" category="SIMD">
    <description>Fused negative multiply-subtract packed double-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmsub132ps" category="SIMD">
    <description>Fused negative multiply-subtract packed single-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmsub132sd" category="SIMD">
    <description>Fused negative multiply-subtract scalar double-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmsub132ss" category="SIMD">
    <description>Fused negative multiply-subtract scalar single-precision (132 form)</description>
  </instruction>
  <instruction name="vfnmsub213pd" category="SIMD">
    <description>Fused negative multiply-subtract packed double-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmsub213ps" category="SIMD">
    <description>Fused negative multiply-subtract packed single-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmsub213sd" category="SIMD">
    <description>Fused negative multiply-subtract scalar double-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmsub213ss" category="SIMD">
    <description>Fused negative multiply-subtract scalar single-precision (213 form)</description>
  </instruction>
  <instruction name="vfnmsub231pd" category="SIMD">
    <description>Fused negative multiply-subtract packed double-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmsub231ps" category="SIMD">
    <description>Fused negative multiply-subtract packed single-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmsub231sd" category="SIMD">
    <description>Fused negative multiply-subtract scalar double-precision (231 form)</description>
  </instruction>
  <instruction name="vfnmsub231ss" category="SIMD">
    <description>Fused negative multiply-subtract scalar single-precision (231 form)</description>
  </instruction>
  <instruction name="vfpclasspd" category="SIMD">
    <description>Test packed double-precision floating-point values for special categories</description>
  </instruction>
  <instruction name="vfpclassps" category="SIMD">
    <description>Test packed single-precision floating-point values for special categories</description>
  </instruction>
  <instruction name="vfpclasssd" category="SIMD">
    <description>Test scalar double-precision floating-point value for special categories</description>
  </instruction>
  <instruction name="vfpclassss" category="SIMD">
    <description>Test scalar single-precision floating-point value for special categories</description>
  </instruction>
  <instruction name="vgatherdpd" category="SIMD">
    <description>Gather packed double-precision floating-point values using doubleword indices</description>
  </instruction>
  <instruction name="vgatherdps" category="SIMD">
    <description>Gather packed single-precision floating-point values using doubleword indices</description>
  </instruction>
  <instruction name="vgatherqpd" category="SIMD">
    <description>Gather packed double-precision floating-point values using quadword indices</description>
  </instruction>
  <instruction name="vgatherqps" category="SIMD">
    <description>Gather packed single-precision floating-point values using quadword indices</description>
  </instruction>
  <instruction name="vgetexppd" category="SIMD">
    <description>Convert exponents of packed double-precision floating-point values to FP values</description>
  </instruction>
  <instruction name="vgetexpps" category="SIMD">
    <description>Convert exponents of packed single-precision floating-point values to FP values</description>
  </instruction>
  <instruction name="vgetexpsd" category="SIMD">
    <description>Convert exponent of scalar double-precision floating-point value to FP value</description>
  </instruction>
  <instruction name="vgetexpss" category="SIMD">
    <description>Convert exponent of scalar single-precision floating-point value to FP value</description>
  </instruction>
  <instruction name="vgetmantpd" category="SIMD">
    <description>Extract mantissas of packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vgetmantps" category="SIMD">
    <description>Extract mantissas of packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vgetmantsd" category="SIMD">
    <description>Extract mantissa of scalar double-precision floating-point value</description>
  </instruction>
  <instruction name="vgetmantss" category="SIMD">
    <description>Extract mantissa of scalar single-precision floating-point value</description>
  </instruction>
  <instruction name="vhaddpd" category="SIMD">
    <description>Horizontal add packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vhaddps" category="SIMD">
    <description>Horizontal add packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vhsubpd" category="SIMD">
    <description>Horizontal subtract packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vhsubps" category="SIMD">
    <description>Horizontal subtract packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vinsertf128" category="SIMD">
    <description>Insert 128 bits (AVX)</description>
  </instruction>
  <instruction name="vinserti128" category="SIMD">
    <description>Insert 128 bits of integer data (AVX2)</description>
  </instruction>
  <instruction name="vinsertps" category="SIMD">
    <description>Insert packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmaskmovpd" category="SIMD">
    <description>Conditional load/store packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmaskmovps" category="SIMD">
    <description>Conditional load/store packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmaxpd" category="SIMD">
    <description>Maximum of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmaxps" category="SIMD">
    <description>Maximum of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmaxsd" category="SIMD">
    <description>Maximum of scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vmaxss" category="SIMD">
    <description>Maximum of scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vminpd" category="SIMD">
    <description>Minimum of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vminps" category="SIMD">
    <description>Minimum of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vminsd" category="SIMD">
    <description>Minimum of scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vminss" category="SIMD">
    <description>Minimum of scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovapd" category="SIMD">
    <description>Move aligned packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmovaps" category="SIMD">
    <description>Move aligned packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovd" category="SIMD">
    <description>Move doubleword (AVX)</description>
  </instruction>
  <instruction name="vmovddup" category="SIMD">
    <description>Move and duplicate double-precision (AVX)</description>
  </instruction>
  <instruction name="vmovdqa" category="SIMD">
    <description>Move aligned packed integers (AVX)</description>
  </instruction>
  <instruction name="vmovdqu" category="SIMD">
    <description>Move unaligned packed integers (AVX)</description>
  </instruction>
  <instruction name="vmovhlps" category="SIMD">
    <description>Move high to low packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovhpd" category="SIMD">
    <description>Move high packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmovhps" category="SIMD">
    <description>Move high packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovlhps" category="SIMD">
    <description>Move low to high packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovlpd" category="SIMD">
    <description>Move low packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmovlps" category="SIMD">
    <description>Move low packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovmskpd" category="SIMD">
    <description>Extract packed double-precision sign mask (AVX)</description>
  </instruction>
  <instruction name="vmovmskps" category="SIMD">
    <description>Extract packed single-precision sign mask (AVX)</description>
  </instruction>
  <instruction name="vmovntdq" category="SIMD">
    <description>Store packed integers using non-temporal hint (AVX)</description>
  </instruction>
  <instruction name="vmovntdqa" category="SIMD">
    <description>Load double quadword non-temporal aligned hint (AVX)</description>
  </instruction>
  <instruction name="vmovntpd" category="SIMD">
    <description>Store packed double-precision using non-temporal hint (AVX)</description>
  </instruction>
  <instruction name="vmovntps" category="SIMD">
    <description>Store packed single-precision using non-temporal hint (AVX)</description>
  </instruction>
  <instruction name="vmovq" category="SIMD">
    <description>Move quadword (AVX)</description>
  </instruction>
  <instruction name="vmovsd" category="SIMD">
    <description>Move scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vmovshdup" category="SIMD">
    <description>Move and duplicate high single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovsldup" category="SIMD">
    <description>Move and duplicate low single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovss" category="SIMD">
    <description>Move scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vmovupd" category="SIMD">
    <description>Move unaligned packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmovups" category="SIMD">
    <description>Move unaligned packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmulpd" category="SIMD">
    <description>Multiply packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vmulps" category="SIMD">
    <description>Multiply packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vmulsd" category="SIMD">
    <description>Multiply scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vmulss" category="SIMD">
    <description>Multiply scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vorpd" category="SIMD">
    <description>Bitwise OR of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vorps" category="SIMD">
    <description>Bitwise OR of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vpaddb" category="SIMD">
    <description>Add packed bytes (AVX)</description>
  </instruction>
  <instruction name="vpaddd" category="SIMD">
    <description>Add packed doublewords (AVX)</description>
  </instruction>
  <instruction name="vpaddq" category="SIMD">
    <description>Add packed quadwords (AVX)</description>
  </instruction>
  <instruction name="vpaddw" category="SIMD">
    <description>Add packed words (AVX)</description>
  </instruction>
  <instruction name="vpand" category="SIMD">
    <description>Packed AND (AVX)</description>
  </instruction>
  <instruction name="vpandn" category="SIMD">
    <description>Packed AND NOT (AVX)</description>
  </instruction>
  <instruction name="vpblendd" category="SIMD">
    <description>Blend packed doublewords (AVX2)</description>
  </instruction>
  <instruction name="vpbroadcastb" category="SIMD">
    <description>Broadcast byte to all elements (AVX2)</description>
  </instruction>
  <instruction name="vpbroadcastd" category="SIMD">
    <description>Broadcast doubleword to all elements (AVX2)</description>
  </instruction>
  <instruction name="vpbroadcastq" category="SIMD">
    <description>Broadcast quadword to all elements (AVX2)</description>
  </instruction>
  <instruction name="vpbroadcastw" category="SIMD">
    <description>Broadcast word to all elements (AVX2)</description>
  </instruction>
  <instruction name="vpclmulqdq" category="CRYPTO">
    <description>Carry-less multiplication quadword (AVX)</description>
  </instruction>
  <instruction name="vpcompressd" category="SIMD">
    <description>Store sparse packed doubleword values</description>
  </instruction>
  <instruction name="vpcompressq" category="SIMD">
    <description>Store sparse packed quadword values</description>
  </instruction>
  <instruction name="vpconflictd" category="SIMD">
    <description>Detect conflicts within vector of packed doublewords</description>
  </instruction>
  <instruction name="vpconflictq" category="SIMD">
    <description>Detect conflicts within vector of packed quadwords</description>
  </instruction>
  <instruction name="vperm2f128" category="SIMD">
    <description>Permute 128-bit floating-point fields (AVX)</description>
  </instruction>
  <instruction name="vperm2i128" category="SIMD">
    <description>Permute 128-bit integer fields (AVX2)</description>
  </instruction>
  <instruction name="vpermd" category="SIMD">
    <description>Permute packed doublewords (AVX2)</description>
  </instruction>
  <instruction name="vpermi2b" category="SIMD">
    <description>Full permute of two byte tables overwriting the index</description>
  </instruction>
  <instruction name="vpermi2d" category="SIMD">
    <description>Full permute of two doubleword tables overwriting the index</description>
  </instruction>
  <instruction name="vpermi2q" category="SIMD">
    <description>Full permute of two quadword tables overwriting the index</description>
  </instruction>
  <instruction name="vpermi2w" category="SIMD">
    <description>Full permute of two word tables overwriting the index</description>
  </instruction>
  <instruction name="vpermilpd" category="SIMD">
    <description>Permute in-lane packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vpermilps" category="SIMD">
    <description>Permute in-lane packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vpermpd" category="SIMD">
    <description>Permute packed double-precision (AVX2)</description>
  </instruction>
  <instruction name="vpermps" category="SIMD">
    <description>Permute packed single-precision (AVX2)</description>
  </instruction>
  <instruction name="vpermq" category="SIMD">
    <description>Permute packed quadwords (AVX2)</description>
  </instruction>
  <instruction name="vpermt2b" category="SIMD">
    <description>Full permute of two byte tables overwriting one table</description>
  </instruction>
  <instruction name="vpermt2d" category="SIMD">
    <description>Full permute of two doubleword tables overwriting one table</description>
  </instruction>
  <instruction name="vpermt2q" category="SIMD">
    <description>Full permute of two quadword tables overwriting one table</description>
  </instruction>
  <instruction name="vpermt2w" category="SIMD">
    <description>Full permute of two word tables overwriting one table</description>
  </instruction>
  <instruction name="vpexpandd" category="SIMD">
    <description>Load sparse packed doubleword values</description>
  </instruction>
  <instruction name="vpexpandq" category="SIMD">
    <description>Load sparse packed quadword values</description>
  </instruction>
  <instruction name="vpgatherdd" category="SIMD">
    <description>Gather packed doubleword values using doubleword indices</description>
  </instruction>
  <instruction name="vpgatherdq" category="SIMD">
    <description>Gather packed quadword values using doubleword indices</description>
  </instruction>
  <instruction name="vpgatherqd" category="SIMD">
    <description>Gather packed doubleword values using quadword indices</description>
  </instruction>
  <instruction name="vpgatherqq" category="SIMD">
    <description>Gather packed quadword values using quadword indices</description>
  </instruction>
  <instruction name="vplzcntd" category="SIMD">
    <description>Count number of leading zero bits in packed doublewords</description>
  </instruction>
  <instruction name="vplzcntq" category="SIMD">
    <description>Count number of leading zero bits in packed quadwords</description>
  </instruction>
  <instruction name="vpmaskmovd" category="SIMD">
    <description>Conditional load/store packed doublewords (AVX2)</description>
  </instruction>
  <instruction name="vpmaskmovq" category="SIMD">
    <description>Conditional load/store packed quadwords (AVX2)</description>
  </instruction>
  <instruction name="vpmovb2m" category="SIMD">
    <description>Convert byte vector to mask register</description>
  </instruction>
  <instruction name="vpmovd2m" category="SIMD">
    <description>Convert doubleword vector to mask register</description>
  </instruction>
  <instruction name="vpmovdb" category="SIMD">
    <description>Down-convert doubleword to byte with truncation</description>
  </instruction>
  <instruction name="vpmovdw" category="SIMD">
    <description>Down-convert doubleword to word with truncation</description>
  </instruction>
  <instruction name="vpmovm2b" category="SIMD">
    <description>Convert mask register to byte vector</description>
  </instruction>
  <instruction name="vpmovm2d" category="SIMD">
    <description>Convert mask register to doubleword vector</description>
  </instruction>
  <instruction name="vpmovm2q" category="SIMD">
    <description>Convert mask register to quadword vector</description>
  </instruction>
  <instruction name="vpmovm2w" category="SIMD">
    <description>Convert mask register to word vector</description>
  </instruction>
  <instruction name="vpmovq2m" category="SIMD">
    <description>Convert quadword vector to mask register</description>
  </instruction>
  <instruction name="vpmovqb" category="SIMD">
    <description>Down-convert quadword to byte with truncation</description>
  </instruction>
  <instruction name="vpmovqd" category="SIMD">
    <description>Down-convert quadword to doubleword with truncation</description>
  </instruction>
  <instruction name="vpmovqw" category="SIMD">
    <description>Down-convert quadword to word with truncation</description>
  </instruction>
  <instruction name="vpmovsdb" category="SIMD">
    <description>Down-convert doubleword to byte with signed saturation</description>
  </instruction>
  <instruction name="vpmovsdw" category="SIMD">
    <description>Down-convert doubleword to word with signed saturation</description>
  </instruction>
  <instruction name="vpmovsqb" category="SIMD">
    <description>Down-convert quadword to byte with signed saturation</description>
  </instruction>
  <instruction name="vpmovsqd" category="SIMD">
    <description>Down-convert quadword to doubleword with signed saturation</description>
  </instruction>
  <instruction name="vpmovsqw" category="SIMD">
    <description>Down-convert quadword to word with signed saturation</description>
  </instruction>
  <instruction name="vpmovswb" category="SIMD">
    <description>Down-convert word to byte with signed saturation</description>
  </instruction>
  <instruction name="vpmovusdb" category="SIMD">
    <description>Down-convert doubleword to byte with unsigned saturation</description>
  </instruction>
  <instruction name="vpmovusdw" category="SIMD">
    <description>Down-convert doubleword to word with unsigned saturation</description>
  </instruction>
  <instruction name="vpmovusqb" category="SIMD">
    <description>Down-convert quadword to byte with unsigned saturation</description>
  </instruction>
  <instruction name="vpmovusqd" category="SIMD">
    <description>Down-convert quadword to doubleword with unsigned saturation</description>
  </instruction>
  <instruction name="vpmovusqw" category="SIMD">
    <description>Down-convert quadword to word with unsigned saturation</description>
  </instruction>
  <instruction name="vpmovuswb" category="SIMD">
    <description>Down-convert word to byte with unsigned saturation</description>
  </instruction>
  <instruction name="vpmovw2m" category="SIMD">
    <description>Convert word vector to mask register</description>
  </instruction>
  <instruction name="vpmovwb" category="SIMD">
    <description>Down-convert word to byte with truncation</description>
  </instruction>
  <instruction name="vpmulhuw" category="SIMD">
    <description>Multiply packed unsigned words and store high result (AVX)</description>
  </instruction>
  <instruction name="vpmulhw" category="SIMD">
    <description>Multiply packed signed words and store high result (AVX)</description>
  </instruction>
  <instruction name="vpmulld" category="SIMD">
    <description>Multiply packed signed doubleword integers and store low result (AVX)</description>
  </instruction>
  <instruction name="vpmullw" category="SIMD">
    <description>Multiply packed signed words and store low result (AVX)</description>
  </instruction>
  <instruction name="vpor" category="SIMD">
    <description>Packed OR (AVX)</description>
  </instruction>
  <instruction name="vprold" category="SIMD">
    <description>Rotate packed doublewords left by immediate count</description>
  </instruction>
  <instruction name="vprolq" category="SIMD">
    <description>Rotate packed quadwords left by immediate count</description>
  </instruction>
  <instruction name="vprolvd" category="SIMD">
    <description>Rotate packed doublewords left by variable count</description>
  </instruction>
  <instruction name="vprolvq" category="SIMD">
    <description>Rotate packed quadwords left by variable count</description>
  </instruction>
  <instruction name="vprord" category="SIMD">
    <description>Rotate packed doublewords right by immediate count</description>
  </instruction>
  <instruction name="vprorq" category="SIMD">
    <description>Rotate packed quadwords right by immediate count</description>
  </instruction>
  <instruction name="vprorvd" category="SIMD">
    <description>Rotate packed doublewords right by variable count</description>
  </instruction>
  <instruction name="vprorvq" category="SIMD">
    <description>Rotate packed quadwords right by variable count</description>
  </instruction>
  <instruction name="vpscatterdd" category="SIMD">
    <description>Scatter packed doubleword values with doubleword indices</description>
  </instruction>
  <instruction name="vpscatterdq" category="SIMD">
    <description>Scatter packed quadword values with doubleword indices</description>
  </instruction>
  <instruction name="vpscatterqd" category="SIMD">
    <description>Scatter packed doubleword values with quadword indices</description>
  </instruction>
  <instruction name="vpscatterqq" category="SIMD">
    <description>Scatter packed quadword values with quadword indices</description>
  </instruction>
  <instruction name="vpsllvd" category="SIMD">
    <description>Variable shift packed doublewords left logical (AVX2)</description>
  </instruction>
  <instruction name="vpsllvq" category="SIMD">
    <description>Variable shift packed quadwords left logical (AVX2)</description>
  </instruction>
  <instruction name="vpsravd" category="SIMD">
    <description>Variable shift packed doublewords right arithmetic (AVX2)</description>
  </instruction>
  <instruction name="vpsrlvd" category="SIMD">
    <description>Variable shift packed doublewords right logical (AVX2)</description>
  </instruction>
  <instruction name="vpsrlvq" category="SIMD">
    <description>Variable shift packed quadwords right logical (AVX2)</description>
  </instruction>
  <instruction name="vpsubb" category="SIMD">
    <description>Subtract packed bytes (AVX)</description>
  </instruction>
  <instruction name="vpsubd" category="SIMD">
    <description>Subtract packed doublewords (AVX)</description>
  </instruction>
  <instruction name="vpsubq" category="SIMD">
    <description>Subtract packed quadwords (AVX)</description>
  </instruction>
  <instruction name="vpsubw" category="SIMD">
    <description>Subtract packed words (AVX)</description>
  </instruction>
  <instruction name="vpternlogd" category="SIMD">
    <description>Bitwise ternary logic operation on doubleword elements</description>
  </instruction>
  <instruction name="vpternlogq" category="SIMD">
    <description>Bitwise ternary logic operation on quadword elements</description>
  </instruction>
  <instruction name="vptest" category="SIMD">
    <description>Logical compare (AVX)</description>
  </instruction>
  <instruction name="vpxor" category="SIMD">
    <description>Packed XOR (AVX)</description>
  </instruction>
  <instruction name="vrangepd" category="SIMD">
    <description>Range restriction calculation for packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vrangeps" category="SIMD">
    <description>Range restriction calculation for packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vrangesd" category="SIMD">
    <description>Range restriction calculation for scalar double-precision floating-point values</description>
  </instruction>
  <instruction name="vrangess" category="SIMD">
    <description>Range restriction calculation for scalar single-precision floating-point values</description>
  </instruction>
  <instruction name="vrcp14pd" category="SIMD">
    <description>Compute approximate reciprocals of packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vrcp14ps" category="SIMD">
    <description>Compute approximate reciprocals of packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vrcp14sd" category="SIMD">
    <description>Compute approximate reciprocal of scalar double-precision floating-point value</description>
  </instruction>
  <instruction name="vrcp14ss" category="SIMD">
    <description>Compute approximate reciprocal of scalar single-precision floating-point value</description>
  </instruction>
  <instruction name="vrcpps" category="SIMD">
    <description>Reciprocal of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vrcpss" category="SIMD">
    <description>Reciprocal of scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vreducepd" category="SIMD">
    <description>Perform reduction transformation on packed double-precision floating-point values</description>
  </instruction>
  <instruction name="vreduceps" category="SIMD">
    <description>Perform reduction transformation on packed single-precision floating-point values</description>
  </instruction>
  <instruction name="vreducesd" category="SIMD">
    <description>Perform reduction transformation on scalar double-precision floating-point value</description>
  </instruction>
  <instruction name="vreducess" category="SIMD">
    <description>Perform reduction transformation on scalar single-precision floating-point value</description>
  </instruction>
  <instruction name="vrndscalepd" category="SIMD">
    <description>Round packed double-precision floating-point values to a number of fraction bits</description>
  </instruction>
  <instruction name="vrndscaleps" category="SIMD">
    <description>Round packed single-precision floating-point values to a number of fraction bits</description>
  </instruction>
  <instruction name="vrndscalesd" category="SIMD">
    <description>Round scalar double-precision floating-point value to a number of fraction bits</description>
  </instruction>
  <instruction name="vrndscaless" category="SIMD">
    <description>Round scalar single-precision floating-point value to a number of fraction bits</description>
  </instruction>
  <instruction name="vroundpd" category="SIMD">
    <description>Round packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vroundps" category="SIMD">
    <description>Round packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vroundsd" category="SIMD">
    <description>Round scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vroundss" category="SIMD">
    <description>Round scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vrsqrt14pd" category="SIMD">
    <description>Compute approximate reciprocals of square roots of packed double-precision values</description>
  </instruction>
  <instruction name="vrsqrt14ps" category="SIMD">
    <description>Compute approximate reciprocals of square roots of packed single-precision values</description>
  </instruction>
  <instruction name="vrsqrt14sd" category="SIMD">
    <description>Compute approximate reciprocal of square root of scalar double-precision value</description>
  </instruction>
  <instruction name="vrsqrt14ss" category="SIMD">
    <description>Compute approximate reciprocal of square root of scalar single-precision value</description>
  </instruction>
  <instruction name="vrsqrtps" category="SIMD">
    <description>Reciprocal square root of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vrsqrtss" category="SIMD">
    <description>Reciprocal square root of scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vscalefpd" category="SIMD">
    <description>Scale packed double-precision floating-point values by powers of two</description>
  </instruction>
  <instruction name="vscalefps" category="SIMD">
    <description>Scale packed single-precision floating-point values by powers of two</description>
  </instruction>
  <instruction name="vscalefsd" category="SIMD">
    <description>Scale scalar double-precision floating-point value by power of two</description>
  </instruction>
  <instruction name="vscalefss" category="SIMD">
    <description>Scale scalar single-precision floating-point value by power of two</description>
  </instruction>
  <instruction name="vscatterdpd" category="SIMD">
    <description>Scatter packed double-precision floating-point values with doubleword indices</description>
  </instruction>
  <instruction name="vscatterdps" category="SIMD">
    <description>Scatter packed single-precision floating-point values with doubleword indices</description>
  </instruction>
  <instruction name="vscatterqpd" category="SIMD">
    <description>Scatter packed double-precision floating-point values with quadword indices</description>
  </instruction>
  <instruction name="vscatterqps" category="SIMD">
    <description>Scatter packed single-precision floating-point values with quadword indices</description>
  </instruction>
  <instruction name="vshufi32x4" category="SIMD">
    <description>Shuffle 128-bit lanes of packed 32-bit values</description>
  </instruction>
  <instruction name="vshufi64x2" category="SIMD">
    <description>Shuffle 128-bit lanes of packed 64-bit values</description>
  </instruction>
  <instruction name="vshufpd" category="SIMD">
    <description>Shuffle packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vshufps" category="SIMD">
    <description>Shuffle packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vsqrtpd" category="SIMD">
    <description>Square root of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vsqrtps" category="SIMD">
    <description>Square root of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vsqrtsd" category="SIMD">
    <description>Square root of scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vsqrtss" category="SIMD">
    <description>Square root of scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vsubpd" category="SIMD">
    <description>Subtract packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vsubps" category="SIMD">
    <description>Subtract packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vsubsd" category="SIMD">
    <description>Subtract scalar double-precision (AVX)</description>
  </instruction>
  <instruction name="vsubss" category="SIMD">
    <description>Subtract scalar single-precision (AVX)</description>
  </instruction>
  <instruction name="vucomisd" category="SIMD">
    <description>Compare scalar unordered double-precision (AVX)</description>
  </instruction>
  <instruction name="vucomiss" category="SIMD">
    <description>Compare scalar unordered single-precision (AVX)</description>
  </instruction>
  <instruction name="vunpckhpd" category="SIMD">
    <description>Unpack high packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vunpckhps" category="SIMD">
    <description>Unpack high packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vunpcklpd" category="SIMD">
    <description>Unpack low packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vunpcklps" category="SIMD">
    <description>Unpack low packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vxorpd" category="SIMD">
    <description>Bitwise XOR of packed double-precision (AVX)</description>
  </instruction>
  <instruction name="vxorps" category="SIMD">
    <description>Bitwise XOR of packed single-precision (AVX)</description>
  </instruction>
  <instruction name="vzeroall" category="SIMD">
    <description>Zero all YMM registers</description>
  </instruction>
  <instruction name="vzeroupper" category="SIMD">
    <description>Zero upper 128 bits of YMM registers</description>
  </instruction>
  <instruction name="wait" category="SYSTEM">
    <description>Wait for FPU</description>
  </instruction>
  <instruction name="wbinvd" category="SYSTEM">
    <description>Write back and invalidate cache</description>
  </instruction>
  <instruction name="wrmsr" category="SYSTEM">
    <description>Write model specific register</description>
    <variants>
      <variant />
    </variants>
    <documentation>
      <summary>Write Model-Specific Register</summary>
      <description>Writes the 64-bit value in registers EDX:EAX to the Model-Specific Register (MSR) specified in the ECX register. This instruction is privileged (CPL=0) and can only be executed in kernel mode.</description>
      <operation>MSR[ECX] := EDX:EAX</operation>
      <flags-affected>None</flags-affected>
      <notes>Privileged instruction. Input: ECX contains the MSR address, EDX contains high 32 bits, EAX contains low 32 bits.</notes>
    </documentation>
  </instruction>
  <instruction name="xadd" category="DATA_MOVEMENT">
    <description>Exchange and add</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
    </variants>
    <documentation>
      <summary>Exchange and Add</summary>
      <description>Exchanges the first operand with the second operand, then loads the sum of the two values into the destination operand. Can be combined with the LOCK prefix for atomic operation.</description>
      <operation>temp := DEST
DEST := DEST + SRC
SRC := temp</operation>
      <flags-affected>OF, SF, ZF, AF, PF, CF</flags-affected>
      <notes>Often used with LOCK prefix for atomic operations in multithreaded code.</notes>
    </documentation>
  </instruction>
  <instruction name="xchg" category="DATA_MOVEMENT">
    <description>Exchange values</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="REG8" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
    </variants>
    <documentation>
      <summary>Exchange Register/Memory with Register</summary>
      <description>Exchanges the values of two operands. The operands can be two registers or a register and a memory location. Both operands must be the same size.</description>
      <operation>temp := DEST
DEST := SRC
SRC := temp</operation>
      <flags-affected>None</flags-affected>
      <notes>XCHG with memory operand has an implicit LOCK prefix, making it atomic.</notes>
    </documentation>
  </instruction>
  <instruction name="xgetbv" category="SYSTEM">
    <description>Get value of extended control register</description>
  </instruction>
  <instruction name="xor" category="LOGIC">
    <description>Logical XOR</description>
    <variants>
      <variant>
        <operand type="R_M8" />
        <operand type="REG8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="REG16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="REG32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="REG64" />
      </variant>
      <variant>
        <operand type="REG8" />
        <operand type="R_M8" />
      </variant>
      <variant>
        <operand type="REG16" />
        <operand type="R_M16" />
      </variant>
      <variant>
        <operand type="REG32" />
        <operand type="R_M32" />
      </variant>
      <variant>
        <operand type="REG64" />
        <operand type="R_M64" />
      </variant>
      <variant>
        <operand type="R_M8" />
        <operand type="IMM8" />
      </variant>
      <variant>
        <operand type="R_M16" />
        <operand type="IMM16" />
      </variant>
      <variant>
        <operand type="R_M32" />
        <operand type="IMM32" />
      </variant>
      <variant>
        <operand type="R_M64" />
        <operand type="IMM32" />
      </variant>
    </variants>
    <documentation>
      <summary>Logical Exclusive OR</summary>
      <description>Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location.</description>
      <operation>DEST := DEST XOR SRC</operation>
      <flags-affected>OF=0, CF=0, SF, ZF, PF (AF undefined)</flags-affected>
      <notes>XOR reg, reg is commonly used to zero a register. OF and CF flags are cleared.</notes>
    </documentation>
  </instruction>
  <instruction name="xorpd" category="SIMD">
    <description>Bitwise XOR of packed double-precision</description>
  </instruction>
  <instruction name="xorps" category="SIMD">
    <description>Bitwise XOR of packed single-precision</description>
  </instruction>
  <instruction name="xrstor" category="SYSTEM">
    <description>Restore processor extended states</description>
  </instruction>
  <instruction name="xrstor64" category="SYSTEM">
    <description>Restore processor extended states (64-bit)</description>
  </instruction>
  <instruction name="xrstors" category="SYSTEM">
    <description>Restore processor extended states supervisor</description>
  </instruction>
  <instruction name="xrstors64" category="SYSTEM">
    <description>Restore processor extended states supervisor (64-bit)</description>
  </instruction>
  <instruction name="xsave" category="SYSTEM">
    <description>Save processor extended states</description>
  </instruction>
  <instruction name="xsave64" category="SYSTEM">
    <description>Save processor extended states (64-bit)</description>
  </instruction>
  <instruction name="xsavec" category="SYSTEM">
    <description>Save processor extended states with compaction</description>
  </instruction>
  <instruction name="xsavec64" category="SYSTEM">
    <description>Save processor extended states with compaction (64-bit)</description>
  </instruction>
  <instruction name="xsaveopt" category="SYSTEM">
    <description>Save processor extended states optimized</description>
  </instruction>
  <instruction name="xsaveopt64" category="SYSTEM">
    <description>Save processor extended states optimized (64-bit)</description>
  </instruction>
  <instruction name="xsaves" category="SYSTEM">
    <description>Save processor extended states supervisor</description>
  </instruction>
  <instruction name="xsaves64" category="SYSTEM">
    <description>Save processor extended states supervisor (64-bit)</description>
  </instruction>
  <instruction name="xsetbv" category="SYSTEM">
    <description>Set extended control register</description>
  </instruction>
</instructions>
